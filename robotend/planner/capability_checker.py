from semantic_kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables
from dotenv import dotenv_values

from log import logger
from planner.base import Plan, Planner
from retrieval import Retrieval

# PROMPT = """
# 你是一个熟练掌握Web渗透测试知识的规划机器人。
# 你的工作是根据你对渗透测试任务的了解，判断用户[目的]是否需要执行NMAP工具或漏洞检测工具。
# 若不需要执行NMAP工具和漏洞检测工具，则输出"0"。
# 若只需要执行NMAP工具，则输出"1"。
# 若只需要执行漏洞检测工具，则输出"2"。
# 若NMAP工具和漏洞检测工具都需要执行，则输出"3"。
# 请不要输出除了"0"、"1"、"2"、"3"之外任何别的字符,完成后立刻停止输出。
# 下面是两个例子：
# [目的]
# 帮我对www.baidu.com进行端口扫描，并检测是否存在csrf漏洞。
# [输出]
# 3

# [目的]
# 你能帮我检查172.20.0.59:11453的web服务上是否有XSS攻击漏洞吗？
# [输出]
# 2

# 例子完毕，下面开始真实场景应用
# [目的]
# {{$input}}
# [输出]
# """

PROMPT = """
你是一个熟练掌握Web渗透测试知识的规划机器人。
你的工作是根据你对渗透测试任务的了解，判断用户[目的]是否需要使用NMAP工具、w3af工具、CMSeek工具、Dirsearch工具、Hydra工具、Sqlmap工具、Tplmap工具以及XSStrike工具或者进行分析和总结。
若不需要使用任何上述工具，则输出"0"。
若需要使用NMAP工具，则输出"1"。
若需要使用w3af工具，则输出"2"。
若需要使用CMSeek工具，则输出"3"。
若需要使用Dirsearch工具，则输出"4"。
若需要使用Hydra工具，则输出"5"。
若需要使用Sqlmap工具，则输出"6"。
若需要使用Tplmap工具，则输出"7"。
若需要使用XSStrike工具，则输出"8"。
若需要进行分析或总结，则输出"9"
请不要输出除了"0"、"1"、"2"、"3"、"4"、"5"、"6"、"7"、"8"、"9"之外任何别的字符,完成后立刻停止输出。
下面是两个例子：
[目的]
帮我对www.baidu.com进行端口扫描，并检测是否存在csrf漏洞。
[输出]


[目的]
你能帮我检查172.20.0.59:11453的web服务上是否有XSS攻击漏洞吗？
[输出]
8

例子完毕，下面开始真实场景应用
[目的]
{{$input}}
[输出]
"""


class CapChecker(Planner):

    def __init__(self, kernel: Kernel, skill_name: str, reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = kernel.create_semantic_function(PROMPT, max_tokens=300, temperature=0.8)

    async def create_plan_async(self, goal: str) -> Plan | None:
        logger.info(f": 需求检测查询输入- {repr(goal)}")

        # Create the context for the planner
        context = ContextVariables()
        # Add the input to the context
        context["input"] = goal
        response = await self.planner.invoke_async(variables=context)
        # print("response:", response)
        config = dotenv_values(".env")
        model_load_type = config.get("GLOBAL__LLM_CALL_TYPE", None)
        if model_load_type == "local":
            result = response.result.split("[end of text]")[0].split("[输出]")[4].split("[意图]")[0]
        else:
            result = response.result
        # logger.info(f": Capability check result - {repr(result)}")

        return Plan(prompt=PROMPT, goal=goal, generated_plan=result)

    async def execute_plan_async(self, plan: Plan) -> str:
        return plan.generated_plan
