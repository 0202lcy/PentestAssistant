"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
from typing import Tuple, Optional
from dotenv import dotenv_values

from semantic_kernel.kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables

from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """
You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan, to satisfy the goal given.
Create a list of tasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which functions to use from the description and the name of the function.
For example:

[AVAILABLE FUNCTIONS]
authorization
description: scan authorization and authentication-related vulnerabilities, including user login, cookie, and encryption
args:
- target: scan ip or url address

buffer_overflow
description: scan Buffer overflow vulnerabilities
args:
- target: scan ip or url address

code_and_command_injection
description: scan code injection and command-line injection vulnerabilities detection. This includes remote execution of user-defined code or programs, allowing users to perform any operation or even obtain a shell
args:
- target: scan ip or url address

generic
description: scan vulnerabilities include the most common vulnerability scanning combinations
args:
- target: scan ip or url address

[GOAL]
please scan some common vulnerabilities for host 222.20.123.321:8023

[OUTPUT]
{
    "host" : "222.20.123.321:8023",
    "configs": ["generic"]
}

[AVAILABLE FUNCTIONS]
{{$available_functions}}

[GOAL]
{{$goal}}

[OUTPUT]
"""

PROMPT_WENXIN = """
你是一名熟练掌握渗透测试知识的规划师。
你的工作是创建一个格式正确的 JSON 计划，以满足给定的目标。
Json计划中只包含"host"和"configs"两个键，请勿使用和添加其他键值对。
根据提供的 [GOAL] 创建任务列表。
每个子任务都必须来自 [AVAILABLE FUNCTIONS] 列表。请勿使用功能列表中没有的任何功能。
对于目标中无法通过功能列表中的功能完成的任务，请忽视它们，而不是创建或添加其他功能和字段，请勿自己添加功能和字段。
"configs"的值仅从 [AVAILABLE FUNCTIONS] 列表中选取相应的功能名，请勿添加或创建其他功能。
请不要将自己创建的功能或者不能通过[AVAILABLE FUNCTIONS] 列表中功能完成的任务添加到"configs"键的值中。
根据description和功能名称来决定使用哪些功能。
For example:

[AVAILABLE FUNCTIONS]
authorization
description: scan authorization and authentication-related vulnerabilities, including user login, cookie, and encryption
args:
- target: scan ip or url address

buffer_overflow
description: scan Buffer overflow vulnerabilities
args:
- target: scan ip or url address

code_and_command_injection
description: scan code injection and command-line injection vulnerabilities detection. This includes remote execution of user-defined code or programs, allowing users to perform any operation or even obtain a shell
args:
- target: scan ip or url address

generic
description: scan vulnerabilities include the most common vulnerability scanning combinations
args:
- target: scan ip or url address

[GOAL]
please scan some common vulnerabilities for host 222.20.123.321:8023

[OUTPUT]
{
    "host" : "222.20.123.321:8023",
    "configs": ["generic"]
}

[AVAILABLE FUNCTIONS]
{{$available_functions}}

[GOAL]
{{$goal}}

[OUTPUT]
"""

FORMAT_PROMPT_LOG = """
You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan, to satisfy the goal given.
Create a list of tasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which functions to use from the description and the name of the function.
For example:

[AVAILABLE FUNCTIONS]
authorization
description: scan authorization and authentication-related vulnerabilities, including user login, cookie, and encryption
args:
- target: scan ip or url address

buffer_overflow
description: scan Buffer overflow vulnerabilities
args:
- target: scan ip or url address

code_and_command_injection
description: scan code injection and command-line injection vulnerabilities detection. This includes remote execution of user-defined code or programs, allowing users to perform any operation or even obtain a shell
args:
- target: scan ip or url address

generic
description: scan vulnerabilities include the most common vulnerability scanning combinations
args:
- target: scan ip or url address

[GOAL]
please scan some common vulnerabilities for host 222.20.123.321:8023

[OUTPUT]
{{
    "host" : "222.20.123.321:8023",
    "configs": ["generic"]
}}

[AVAILABLE FUNCTIONS]
{available_functions}

[GOAL]
{goal}

[OUTPUT]
"""

FORMAT_PROMPT_WENXIN_LOG = """
你是一名熟练掌握渗透测试知识的规划师。
你的工作是创建一个格式正确的 JSON 计划，以满足给定的目标。
Json计划中只包含"host"和"configs"两个键，请勿使用和添加其他键值对。
根据提供的 [GOAL] 创建任务列表。
每个子任务都必须来自 [AVAILABLE FUNCTIONS] 列表。请勿使用功能列表中没有的任何功能。
对于目标中无法通过功能列表中的功能完成的任务，请忽视它们，而不是创建或添加其他功能和字段，请勿自己添加功能和字段。
"configs"的值仅从 [AVAILABLE FUNCTIONS] 列表中选取相应的功能名，请勿添加或创建其他功能。
请不要将自己创建的功能或者不能通过[AVAILABLE FUNCTIONS] 列表中功能完成的任务添加到"configs"键的值中。
根据description和功能名称来决定使用哪些功能。
For example:

[AVAILABLE FUNCTIONS]
authorization
description: scan authorization and authentication-related vulnerabilities, including user login, cookie, and encryption
args:
- target: scan ip or url address

buffer_overflow
description: scan Buffer overflow vulnerabilities
args:
- target: scan ip or url address

code_and_command_injection
description: scan code injection and command-line injection vulnerabilities detection. This includes remote execution of user-defined code or programs, allowing users to perform any operation or even obtain a shell
args:
- target: scan ip or url address

generic
description: scan vulnerabilities include the most common vulnerability scanning combinations
args:
- target: scan ip or url address

[GOAL]
please scan some common vulnerabilities for host 222.20.123.321:8023

[OUTPUT]
{{
    "host" : "222.20.123.321:8023",
    "configs": ["generic"]
}}

[AVAILABLE FUNCTIONS]
{available_functions}

[GOAL]
{goal}

[OUTPUT]
"""

config = dotenv_values(".env")
LLM = config.get("GLOBAL__LLM_SERVICE", None)

if LLM == "WenXin":
    PROMPT = PROMPT_WENXIN
    FORMAT_PROMPT_LOG = FORMAT_PROMPT_WENXIN_LOG


class VulnerabilityPlanner(Planner):
    """
    Basic JSON-based planner for the Semantic Kernel.
    """

    def __init__(self, kernel: Kernel, skill_name: str, reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = self.kernel.create_semantic_function(PROMPT, max_tokens=500, temperature=0.8)

    def _create_available_functions_string(self, kernel: Kernel) -> str:
        """
        Given an instance of the Kernel, create the [AVAILABLE FUNCTIONS]
        string for the prompt.
        """
        functions = kernel.skills.get_functions_view().native_functions.get(self.skill_name)

        available_functions_string = ""
        for function in functions:
            available_functions_string += f"{function.name}\n"
            available_functions_string += f"description: {function.description}\n"
            available_functions_string += f"args:\n"
            for arg in function.parameters:
                available_functions_string += f"- {arg.name}: {arg.description}\n"
            available_functions_string += "\n"

        logger.info(
            ": 可供选择的API - {available_functions_string}".format(available_functions_string=available_functions_string))
        return available_functions_string

    def _check_subtasks_format(self, generated_plan: dict) -> bool:
        """
        check if json have correct field, should be:
        Dict["target": str, "tasks": List[str]]
        Dict["subtasks": List[Dict["function": "function_name", "args": List[Dict[str, str]]]]]
        """
        if "host" not in generated_plan:
            return False
        if "configs" not in generated_plan:
            return False
        if not isinstance(generated_plan.get("host"), str):
            return False
        if not isinstance(generated_plan.get("configs"), list):
            return False
        for task in generated_plan.get("configs"):
            if not isinstance(task, str):
                return False
        return True

    def _check_generated_plan(self, generated_plan: str, kernel: Kernel) -> Tuple[Optional[dict], str]:
        """
        check if generate_plan have json format plan, and set default
        value for args
        Warning: arg name cannot be 'input'
        """
        config = dotenv_values(".env")
        model_load_type = config.get("GLOBAL__LLM_CALL_TYPE", None)
        logger.info(":大模型输出: {plan}".format(plan=generated_plan))
        json_regex = r"\{(?:[^{}]|(?R))*\}"
        if model_load_type == "local":
            # check if these is json plan
            generated_plan_string_list = regex.findall(json_regex, generated_plan)
            if len(generated_plan_string_list) < 2:
                logger.debug(": Fail - Check Generated Plan: plan donnot have json")
                return None, "生成的计划中不含有json形式函数调用序列"
            generated_plan_string = generated_plan_string_list[1]
        else:
            generated_plan_string = regex.findall(json_regex, generated_plan)[0]
        # use 3rd json as plan
        if len(generated_plan_string) == 0:
            return None, "调用过多，请稍后再试"
        try:
            generated_plan_json = json.loads(generated_plan_string)
        except:
            logger.info(": Check Generated Plan: {plan}".format(plan=repr(generated_plan_string)))
            return None, "生成的计划中json格式函数调用序列格式错误"

        # check json format
        if not self._check_subtasks_format(generated_plan_json):
            logger.debug(": Fail - Check Generated Plan: plan donnot have correct format subtasks")
            return None, "生成的计划中json格式函数调用序列格式错误"
        if not generated_plan_json.get("configs"):
            return None, "生成的计划中不含可调用的配置或函数"
        for function_name in generated_plan_json["configs"]:
            if not kernel.skills.has_native_function(self.skill_name, function_name):
                return None, "生成的计划中调用函数不在可用范围内"

        return generated_plan_json, ""

    async def create_plan_async(
        self,
        goal: str,
    ) -> Tuple[str, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """
        logger.info(f"漏洞检测目标: {goal}")

        # Create the semantic function for the planner with the given prompt
        available_functions_string = self._create_available_functions_string(self.kernel)

        # Create the context for the planner
        context = ContextVariables()
        # Add the goal to the context
        context["goal"] = goal
        context["available_functions"] = available_functions_string
        formatted_prompt = FORMAT_PROMPT_LOG.format(available_functions=available_functions_string, goal=goal)
        logger.info(f"大模型输入: {formatted_prompt}")
        generated_plan = await self.planner.invoke_async(variables=context)
        # print("generated_plan:", generated_plan)
        generated_plan_json, error_message = self._check_generated_plan(generated_plan.result, self.kernel)
        if len(error_message) == 0:
            logger.info(f"漏洞检测生成计划: {repr(generated_plan_json)}")
            return "", Plan(prompt=PROMPT, goal=goal, generated_plan=generated_plan_json)

        logger.error(f"Vulnerability Detection Create Plan Fail: {repr(generated_plan)}")
        return error_message, None

    async def execute_plan_async(self, plan: Plan) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": 执行计划: {plan}".format(plan=repr(plan.generated_plan)))

        # only return plan is ok
        result = plan.generated_plan
        return result
