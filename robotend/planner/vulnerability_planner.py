"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
from typing import Tuple, Optional

from semantic_kernel.kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables

from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """
You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan, to satisfy the goal given.
Create a list of tasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which functions to use from the description and the name of the function.
For example:

[AVAILABLE FUNCTIONS]
authorization
description: scan authorization and authentication-related vulnerabilities, including user login, cookie, and encryption
args:
- target: scan ip or url address

buffer_overflow
description: scan Buffer overflow vulnerabilities
args:
- target: scan ip or url address

code_and_command_injection
description: scan code injection and command-line injection vulnerabilities detection. This includes remote execution of user-defined code or programs, allowing users to perform any operation or even obtain a shell
args:
- target: scan ip or url address

generic
description: scan vulnerabilities include the most common vulnerability scanning combinations
args:
- target: scan ip or url address

[GOAL]
please scan some common vulnerabilities for host 222.20.123.321:8023

[OUTPUT]
{
    "host" : "222.20.123.321:8023",
    "configs": ["generic"]
}

[AVAILABLE FUNCTIONS]
{{$available_functions}}

[GOAL]
{{$goal}}

[OUTPUT]
"""


class VulnerabilityPlanner(Planner):
    """
    Basic JSON-based planner for the Semantic Kernel.
    """

    def __init__(self,
                 kernel: Kernel,
                 skill_name: str,
                 reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = self.kernel.create_semantic_function(PROMPT,
                                                            max_tokens=500,
                                                            temperature=0.8)

    def _create_available_functions_string(self, kernel: Kernel) -> str:
        """
        Given an instance of the Kernel, create the [AVAILABLE FUNCTIONS]
        string for the prompt.
        """
        functions = kernel.skills.get_functions_view().native_functions.get(
            self.skill_name)

        available_functions_string = ""
        for function in functions:
            available_functions_string += f"{function.name}\n"
            available_functions_string += f"description: {function.description}\n"
            available_functions_string += f"args:\n"
            for arg in function.parameters:
                available_functions_string += f"- {arg.name}: {arg.description}\n"
            available_functions_string += "\n"

        logger.info(
            ": Available Function - {available_functions_string}".format(
                available_functions_string=repr(available_functions_string)))
        return available_functions_string

    def _check_subtasks_format(self, generated_plan: dict) -> bool:
        """
        check if json have correct field, should be:
        Dict["target": str, "tasks": List[str]]
        Dict["subtasks": List[Dict["function": "function_name", "args": List[Dict[str, str]]]]]
        """
        if "host" not in generated_plan:
            return False
        if "configs" not in generated_plan:
            return False
        if not isinstance(generated_plan.get("host"), str):
            return False
        if not isinstance(generated_plan.get("configs"), list):
            return False
        for task in generated_plan.get("configs"):
            if not isinstance(task, str):
                return False
        return True

    def _check_generated_plan(self, generated_plan: str,
                              kernel: Kernel) -> Tuple[Optional[dict], str]:
        """
        check if generate_plan have json format plan, and set default
        value for args
        Warning: arg name cannot be 'input'
        """
        # check if these is json plan
        json_regex = r"\{(?:[^{}]|(?R))*\}"
        generated_plan_string_list = regex.findall(json_regex, generated_plan)
        if len(generated_plan_string_list) < 2:
            logger.debug(
                ": Fail - Check Generated Plan: plan donnot have json")
            return None, "生成的计划中不含有json形式函数调用序列"

        # use 3rd json as plan
        try:
            generated_plan_json = json.loads(generated_plan_string_list[1])
        except:
            logger.info(": Check Generated Plan: {plan}".format(
                plan=repr(generated_plan_string_list[1])))
            return None, "生成的计划中json格式函数调用序列格式错误"

        # check json format
        if not self._check_subtasks_format(generated_plan_json):
            logger.debug(
                ": Fail - Check Generated Plan: plan donnot have correct format subtasks"
            )
            return None, "生成的计划中json格式函数调用序列格式错误"

        for function_name in generated_plan_json["configs"]:
            if not kernel.skills.has_native_function(self.skill_name,
                                                     function_name):
                return None, "生成的计划中调用函数不在可用范围内"

        return generated_plan_json, ""

    async def create_plan_async(
        self,
        goal: str,
    ) -> Tuple[str, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """
        logger.info(f"Vulnerability Detection Goal: {goal}")

        # Create the semantic function for the planner with the given prompt
        available_functions_string = self._create_available_functions_string(
            self.kernel)

        # Create the context for the planner
        context = ContextVariables()
        # Add the goal to the context
        context["goal"] = goal
        context["available_functions"] = available_functions_string

        generated_plan = await self.planner.invoke_async(variables=context)
        generated_plan_json, error_message = self._check_generated_plan(
            generated_plan.result, self.kernel)
        if len(error_message) == 0:
            logger.info(
                f"Vulnerability Detection Generated Plan: {repr(generated_plan_json)}"
            )
            return "", Plan(prompt=PROMPT,
                            goal=goal,
                            generated_plan=generated_plan_json)

        logger.error(
            f"Vulnerability Detection Create Plan Fail: {repr(generated_plan)}"
        )
        return error_message, None

    async def execute_plan_async(self, plan: Plan) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(
            ": Exec Plan: {plan}".format(plan=repr(plan.generated_plan)))

        # only return plan is ok
        result = plan.generated_plan
        return result
