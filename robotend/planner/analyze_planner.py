from semantic_kernel.kernel import Kernel
from semantic_kernel.orchestration.context_variables import ContextVariables

from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """\
你是一个分析总结机器人，擅长把工具或用户的输出信息进行分析总结。需要被的分析总结的信息在“[信息]”标识下方，请你在[结果]标识下方将分析总结的结果输出出来。
下面是一个例子：
[建议]
Hydra v9.2 (c) 2021 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2024-09-19 02:05:42
[DATA] max 1 task per 1 server, overall 1 task, 1 login try (l:1/p:1), ~1 try per task
[DATA] attacking http-get://10.12.189.59:11452/
[11452][http-get] host: 10.12.189.59 login: websds password: websds123
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2024-09-19 02:05:43\n在执行输入验证时，考虑所有可能相关的属性，包括长度、输入类型、可接受值的完整范围、缺少或多余的输入、语法、相关字段之间的一致性以及符合业务规则。作为业务规则逻辑的示例，“boat”在语法上是有效的，因为它只包含字母数字字符，但如果期望输入只包含像“red”或“blue”这样的颜色，则它是无效的。\n不要仅仅依赖于查找恶意或格式错误的输入。这很可能会漏掉至少一个不受欢迎的输入，特别是如果代码的环境发生变化。这将给攻击者足够的空间来绕过预期的验证。然而，拒绝列表可以用于检测潜在攻击或确定哪些输入是如此格式错误以至于应该被直接拒绝的。\n在构建SQL查询字符串时，使用严格的允许列表，根据请求中参数的预期值来限制字符集。这间接限制了攻击范围，但这种技术不如适当的输出编码和转义重要。\n请注意，适当的输出编码、转义和引用是防止SQL注入最有效的解决方案，尽管输入验证可能提供一定的深度防御。这是因为它有效地限制了输出中可能出现的内容。输入验证并不总能防止SQL注入，特别是如果您需要支持可能包含任意字符的自由文本字段。例如，名字\"O'Reilly\"可能会通过验证步骤，因为它是英语中常见的姓氏。但是，它不能直接插入数据库，因为它包含\"'\"的撇号字符，需要进行转义或其他处理。在这种情况下，去除撇号可能会减少SQL注入的风险，但会产生错误行为，因为将记录错误的名称。\n在可行的情况下，最安全的做法可能是完全禁止使用元字符，而不是转义它们。这将提供一定的深度防御。在数据输入到数据库后，后续处理过程可能忽略在使用之前转义元字符，而您可能无法控制这些处理过程。
[输出]
Hydra工具成功在一次尝试中破解了目标主机 (10.12.189.59:11452) 的HTTP GET服务，找到了有效的用户名和密码组合：`websds/websds123`。

例子完毕，下面开始真实场景应用，输出完结果后结束输出并用[结束]标识。
[信息]
{{$input}}
[结果]
"""


class AnalyzePlanner(Planner):

    def __init__(self,
                 kernel: Kernel,
                 skill_name: str,
                 reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = kernel.create_semantic_function(PROMPT,
                                                       max_tokens=1000,
                                                       temperature=0.8)


    async def create_plan_async(self, goal: str) -> Plan | None:
        logger.info(f": Analyze Planner Goal - {repr(goal)}")

        # Create the context for the planner
        context = ContextVariables()
        # Add the input to the context
        context["input"] = goal
        response = await self.planner.invoke_async(variables=context)
        print("response:", response)
        result = response.result
        logger.info(f": Capability check result - {repr(result)}")

        return Plan(prompt=PROMPT, goal=goal, generated_plan=result)

    async def execute_plan_async(self, plan: Plan) -> str:
        return plan.generated_plan
