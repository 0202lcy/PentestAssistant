from typing import List

import torch
import numpy as np
from retrieval.base import Retrieval
from FlagEmbedding import FlagReranker
import json


class BgeRerankerLargeMultiRetrieval(Retrieval):

    def __init__(self,
                 embedding_name_or_path: str,
                 use_fp16: bool = True) -> None:
        super().__init__(embedding_name_or_path)
        self.reranker = FlagReranker(embedding_name_or_path, use_fp16=use_fp16)

    def _get_top_k_values(self, lst: List[float], top_k: int):
        arr = np.array(lst)
        top_k_indices = np.argsort(arr)[-top_k:]
        top_k_values = arr[top_k_indices]

        top_k_values = list(top_k_values)
        top_k_values.reverse()
        top_k_indices = list(top_k_indices)
        top_k_indices.reverse()
        return top_k_values, top_k_indices

    @torch.no_grad()
    def compute_topk(self, query: str, function_info: dict,
                     keyword2function: dict, top_k: int) -> List[str]:
        function_names = list(function_info.keys())

        description_pairs = [[query, item["description"]]
                             for item in function_info.values()]
        description_scores = self.reranker.compute_score(description_pairs)

        sample_pairs = []
        for item in function_info.values():
            sample_pairs.extend([[query, sample]
                                 for sample in item["samples"]])
        sample_scores = self.reranker.compute_score(sample_pairs)
        sample_scores = [
            sum(sample_scores[i:i + 10]) / 10
            for i in range(0, len(sample_scores), 10)
        ]

        keyword_scores = [0.0] * len(function_info)
        keywords = list(keyword2function.keys())
        for keyword in keywords:
            if keyword in query.lower():
                for function_name in keyword2function[keyword]:
                    keyword_scores[function_names.index(function_name)] = 1

        scores = []
        for i in range(len(function_info)):
            scores.append(
                float(0.5 * description_scores[i] + 0.5 * sample_scores[i] +
                      2 * keyword_scores[i]))
        _, top_k_indices = self._get_top_k_values(scores, top_k)

        sorted_answer = []
        for index in range(0, min(top_k, len(function_info))):
            sorted_answer.append(function_names[top_k_indices[index]])

        return sorted_answer
