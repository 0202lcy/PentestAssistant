from typing import Optional, Union
from dotenv import dotenv_values

from flask import Flask, request
from flask_cors import CORS
from pydantic import BaseModel

from bot import StGPT, bot_state, ReturnCodeEnum

config = dotenv_values(".env")

app = Flask(__name__)
CORS(app)

st_gpt = StGPT(reranker_name_or_path=config.get("RERANKER_EMBEDDING_NAME_OR_PATH", None))
st_gpt.import_skill()


class Response(BaseModel):
    code: int
    msg: str
    data: Optional[Union[str, dict]]


@app.route("/", methods=["GET"])
async def read_root():
    return {"Hello": "World"}


@app.route("/status", methods=["GET"])
async def read_status() -> dict:
    return Response(code=0, msg="成功", data=bot_state.get_state()).dict()


@app.route("/chat", methods=["POST"])
async def chat() -> dict:
    question = request.get_json()["question"]
    print("question:", question)
    return_code, result = await st_gpt.generate_async(question)
    print(f"return code: {return_code}, type: {type(return_code)}")
    print(f"result: {result}, type: {type(result)}")
    # 若执行漏洞检测，result符合json格式。
    result_str = str(result)
    if len(result_str) == 0:
        return Response(code=int(return_code), msg="调用过多，请稍后再试", data=result).dict()
    if result_str[0] == '{':
        return Response(code=int(return_code), msg="根据用户意图，正在进行漏洞检测中", data=result).dict()
    else:
        if return_code == ReturnCodeEnum.CREATE_FUNCTION_PARAM_FAIL:
            return Response(code=int(return_code),
                            msg=st_gpt.nmap_planner.create_completion_prompt(st_gpt.nmap_plan),
                            data=result).dict()
        else:
            return Response(code=int(return_code), msg=result, data="None").dict()


@app.route("/summary", methods=["POST"])
async def summary() -> dict:
    return_code, result = await st_gpt.summary_async(request.files['data'].read())
    return Response(code=int(return_code), msg=result, data=None).dict()


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=7999, debug=True)
