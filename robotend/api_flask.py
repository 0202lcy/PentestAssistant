from typing import Optional, Union
from dotenv import dotenv_values

from flask import Flask, request
from flask_cors import CORS
from pydantic import BaseModel

from bot import StGPT, bot_state, ReturnCodeEnum

config = dotenv_values(".env")

app = Flask(__name__)
CORS(app)

st_gpt = StGPT(
    reranker_name_or_path=config.get("RERANKER_EMBEDDING_NAME_OR_PATH", None))
st_gpt.import_skill()


class Response(BaseModel):
    code: int
    msg: str
    data: Optional[Union[str, dict]]


@app.route("/", methods=["GET"])
async def read_root():
    return {"Hello": "World"}


@app.route("/status", methods=["GET"])
async def read_status() -> dict:
    return Response(code=0, msg="成功", data=bot_state.get_state()).dict()


@app.route("/chat", methods=["POST"])
async def chat() -> dict:
    return_code, result = await st_gpt.generate_async(
        request.get_json()["question"])
    print(f"return code: {return_code}, type: {type(return_code)}")
    print(f"result: {result}, type: {type(result)}")
    if return_code == ReturnCodeEnum.SUCCESS:
        return Response(code=int(return_code),
                        msg="根据用户意图，正在进行漏洞检测中",
                        data=result).dict()
    else:
        if return_code == ReturnCodeEnum.CREATE_FUNCTION_PARAM_FAIL:
            return Response(code=int(return_code),
                            msg=st_gpt.nmap_planner.create_completion_prompt(
                                st_gpt.nmap_plan),
                            data=result).dict()
        else:
            return Response(code=int(return_code), msg=result,
                            data=None).dict()


@app.route("/summary", methods=["POST"])
async def summary() -> dict:
    return_code, result = await st_gpt.summary_async(
        request.files['data'].read())
    return Response(code=int(return_code), msg=result, data=None).dict()


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8001, debug=False)
