from semantic_kernel.skill_definition import (
    sk_function,
    sk_function_context_parameter,
)
from semantic_kernel.orchestration.sk_context import SKContext


class Nmap:

    @sk_function(
        description="Retrieves information from a listening acarsd daemon.",
        name="acarsd_info")
    @sk_function_context_parameter(description="hostname", name="host")
    @sk_function_context_parameter(description="target port", name="port")
    @sk_function_context_parameter(
        default_value="512",
        description=
        "Set the number of bytes to retrieve. The default value is 512.",
        name="acarsd_info_bytes")
    @sk_function_context_parameter(
        default_value="10",
        description="Set the timeout in seconds. The default value is 10.",
        name="acarsd_info_timeout")
    #split
    def acarsd_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script acarsd-info --script-args \"acarsd-info.timeout= {context['acarsd_info_timeout']},acarsd-info.bytes= {context['acarsd_info_bytes']} \" -p {context['port']} {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to get useful information about files from AFP volumes.",
        name="afp_ls")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def afp_ls(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sS -sV -p 548 --script=afp-ls  {context['target']} "
        return print_str

    @sk_function(description="Shows AFP shares and ACLs.",
                 name="afp_showmount")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def afp_showmount(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=afp-showmount  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Performs a HEAD or GET request against either the root directory or any optional directory of an Apache JServ Protocol server and returns the server response headers.",
        name="ajp_headers")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def ajp_headers(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8009  {context['ip']}  --script ajp-headers"
        return print_str

    @sk_function(
        description=
        "Requests a URI over the Apache JServ Protocol and displays the result (or stores it in a file).",
        name="ajp_request")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def ajp_request(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8009  {context['ip']}  --script ajp-request"
        return print_str

    @sk_function(
        description=
        "Detects the All-Seeing Eye service. Provided by some game servers for querying the server's status.",
        name="allseeingeye_info")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def allseeingeye_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV  {context['target']} "
        return print_str

    @sk_function(
        description="Maps IP addresses to autonomous system (AS) numbers.",
        name="asn_query")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        description="The address of a recursive nameserver to use (optional).",
        name="dns")
    #split
    def asn_query(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script asn-query [--script-args dns= {context['dns']} ]  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Discovers and enumerates BACNet Devices collects device information based off standard requests.",
        name="bacnet_info")
    @sk_function_context_parameter(description="target hostname", name="host")
    #split
    def bacnet_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script bacnet-info -sU -p 47808  {context['host']} "
        return print_str

    @sk_function(
        description=
        "A simple banner grabber which connects to an open TCP port and prints out anything sent by the listening service within five seconds.",
        name="banner")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def banner(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=banner  {context['target']} "
        return print_str

    @sk_function(description=
                 "Queries a Bitcoin server for a list of known Bitcoin nodes",
                 name="bitcoin_getaddr")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def bitcoin_getaddr(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8333 --script bitcoin-getaddr  {context['ip']} "
        return print_str

    @sk_function(description=
                 "Extracts version and node information from a Bitcoin server",
                 name="bitcoin_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def bitcoin_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8333 --script bitcoin-info  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Discovers bittorrent peers sharing a file based on a user-supplied torrent file or magnet link.",
        name="bittorrent_discovery")
    @sk_function_context_parameter(
        description="a string containing the filename of the torrent file",
        name="bittorrent_discovery_torrent")
    #split
    def bittorrent_discovery(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script bittorrent-discovery --script-args newtargets,bittorrent-discovery.torrent= {context['bittorrent_discovery_torrent']} "
        return print_str

    @sk_function(
        description=
        "Retrieves printer or scanner information from a remote device supporting the BJNP protocol.",
        name="bjnp_discover")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def bjnp_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 8611,8612 --script bjnp-discover  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Using the CICS transaction CEMT, this script attempts to gather information about the current CICS transaction server region.",
        name="cics_info")
    @sk_function_context_parameter(description="Target ips", name="targets")
    #split
    def cics_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=cics-info -p 23  {context['targets']} "
        return print_str

    @sk_function(
        description=
        "Extracts a list of published applications from the ICA Browser service.",
        name="citrix_enum_apps")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def citrix_enum_apps(self, context: SKContext) -> str:
        print_str = f"sudo ./nmap -sU --script=citrix-enum-apps -p 1604  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Extracts a list of applications, ACLs, and settings from the Citrix XML service.",
        name="citrix_enum_apps_xml")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def citrix_enum_apps_xml(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=citrix-enum-apps-xml -p 80,443,8080  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Extracts the name of the server farm and member servers from Citrix XML service.",
        name="citrix_enum_servers_xml")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def citrix_enum_servers_xml(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=citrix-enum-servers-xml -p 80,443,8080  {context['host']} "
        return print_str

    @sk_function(
        description="Dumps list of available resources from CoAP endpoints.",
        name="coap_resources")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def coap_resources(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p U:5683 -sU --script coap-resources  {context['target']} "
        return print_str

    @sk_function(description="Gets database tables from a CouchDB database.",
                 name="couchdb_databases")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def couchdb_databases(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 5984 --script \"couchdb-databases.nse\"  {context['host']} "
        return print_str

    @sk_function(
        description="Gets database statistics from a CouchDB database.",
        name="couchdb_stats")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def couchdb_stats(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 5984 --script \"couchdb-stats.nse\"  {context['host']} "
        return print_str

    @sk_function(
        description="Lists printers managed by the CUPS printing service.",
        name="cups_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def cups_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 631  {context['ip']}  --script cups-info"
        return print_str

    @sk_function(
        description=
        "Lists currently queued print jobs of the remote CUPS service grouped by printer.",
        name="cups_queue_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def cups_queue_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 631  {context['ip']}  --script cups-queue-info"
        return print_str

    @sk_function(
        description=
        "Retrieves a list of music from a DAAP server. The list includes artist names and album and song titles.",
        name="daap_get_library")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def daap_get_library(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=daap-get-library  {context['target']} "
        return print_str

    @sk_function(
        description="Retrieves the day and time from the Daytime service.",
        name="daytime")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def daytime(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=daytime  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Connects to the IBM DB2 Administration Server (DAS) on TCP or UDP port 523 and exports the server profile.",
        name="db2_das_info")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def db2_das_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Sends a DHCPINFORM request to a host on UDP port 67 to obtain all the local configuration parameters without allocating a new address. ",
        name="dhcp_discover")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def dhcp_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 67 --script=dhcp-discover  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Connects to a dictionary server using the DICT protocol, runs the SHOW SERVER command, and displays the result.",
        name="dict_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def dict_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2628  {context['ip']}  --script dict-info"
        return print_str

    @sk_function(
        description=
        "Attempts to extract information from database servers supporting the DRDA protocol.",
        name="drda_info")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def drda_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV  {context['target']} "
        return print_str

    @sk_function(
        description=
        "This NSE script is used to send a EtherNet/IP packet to a remote device that has TCP 44818 open.",
        name="enip_info")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def enip_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script enip-info -sU -p 44818  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate process info over the Apple Remote Event protocol.",
        name="eppc_enum_processes")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def eppc_enum_processes(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3031  {context['ip']}  --script eppc-enum-processes"
        return print_str

    @sk_function(
        description=
        "Tries to discover firewall rules using an IP TTL expiration technique known as firewalking.",
        name="firewalk")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def firewalk(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=firewalk --traceroute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tridium Niagara Fox is a protocol used within Building Automation Systems.",
        name="fox_info")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def fox_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script fox-info.nse -p 1911  {context['host']} "
        return print_str

    @sk_function(
        description="Queries a GKRellM service for monitoring information.",
        name="gkrellm_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def gkrellm_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 19150  {context['ip']}  --script gkrellm-info"
        return print_str

    @sk_function(
        description=
        "Retrieves GPS time, coordinates and speed from the GPSD network daemon.",
        name="gpsd_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def gpsd_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2947  {context['ip']}  --script gpsd-info"
        return print_str

    @sk_function(
        description=
        "Grabs affiliate network IDs (e.g. Google AdSense or Analytics, Amazon Associates, etc.) from a web page. These can be used to identify pages with the same owner.",
        name="http_affiliate_id")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        default_value="/",
        description="The path to request. Defaults to /.",
        name="http_affiliate_id_url_path")
    #split
    def http_affiliate_id(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-affiliate-id.nse --script-args http-affiliate-id.url-path= {context['http_affiliate_id_url_path']}   {context['target']} "
        return print_str

    @sk_function(
        description=
        "Checks if the target http server has mod_negotiation enabled.",
        name="http_apache_negotiation")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        default_value="/",
        description="target web site root. Defaults to <code>/</code>.",
        name="http_apache_negotiation_root")
    #split
    def http_apache_negotiation(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-apache-negotiation --script-args http-apache-negotiation.root= {context['http_apache_negotiation_root']}   {context['target']} "
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve the server-status page for Apache webservers that have mod_status enabled.",
        name="http_apache_server_status")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_apache_server_status(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-apache-server-status  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Spiders a web site to find web pages requiring form-based or HTTP-based authentication.",
        name="http_auth_finder")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def http_auth_finder(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-auth-finder  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Spiders a website and attempts to identify backup copies of discovered files.",
        name="http_backup_finder")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_backup_finder(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-backup-finder  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Decodes any unencrypted F5 BIG-IP cookies in the HTTP response.",
        name="http_bigip_cookie")
    @sk_function_context_parameter(description="Target port", name="port")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_bigip_cookie(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p  {context['port']}  --script http-bigip-cookie  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Obtains the CakePHP version of a web application built with the CakePHP framework by fingerprinting default files shipped with the CakePHP framework.",
        name="http_cakephp_version")
    @sk_function_context_parameter(description="Target host or ip",
                                   name="target")
    #split
    def http_cakephp_version(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80,443 --script http-cakephp-version  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Measures the time a website takes to deliver a web page and returns the maximum, minimum and average time it took to fetch a page.",
        name="http_chrono")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def http_chrono(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-chrono  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Extracts and outputs HTML and JavaScript comments from HTTP responses.",
        name="http_comments_displayer")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_comments_displayer(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-comments-displayer.nse  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Gets the date from HTTP-like services. Also prints how much the date differs from local time.",
        name="http_date")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_date(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=http-date  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Tests for access with default credentials used by a variety of web applications and devices.",
        name="http_default_accounts")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_default_accounts(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-default-accounts  {context['target']} "
        return print_str

    @sk_function(description=
                 "Tries to find out the technology behind the target website.",
                 name="http_devframework")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_devframework(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-devframework.nse  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Enumerates the installed Drupal modules/themes by using a list of known modules and themes.",
        name="http_drupal_enum")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_drupal_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-drupal-enum  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Enumerates Drupal users by exploiting an information disclosure vulnerability in Views, Drupal's most popular module.",
        name="http_drupal_enum_users")
    @sk_function_context_parameter(description="Target ips and hostnames",
                                   name="targets")
    @sk_function_context_parameter(
        default_value="/",
        description=" base path. Defaults to \"/\" ",
        name="http_drupal_enum_users_root")
    #split
    def http_drupal_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-drupal-enum-users --script-args http-drupal-enum-users.root={context['http_drupal_enum_users_root']}  {context['targets']} "
        return print_str

    @sk_function(
        description=
        "Enumerates directories used by popular web applications and servers.",
        name="http_enum")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=http-enum  {context['target']} "
        return print_str

    @sk_function(
        description=
        "This script crawls through the website and returns any error pages.",
        name="http_errors")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_errors(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-errors.nse  {context['target']} "
        return print_str

    @sk_function(
        description=
        "This script crawls through the website to find any rss or atom feeds.",
        name="http_feed")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_feed(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-feed.nse  {context['target']} "
        return print_str

    @sk_function(description="", name="http_gitweb_projects_enum")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_gitweb_projects_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80  {context['host']}  --script http-gitweb-projects-enum"
        return print_str

    @sk_function(
        description=
        "Checks if hosts are on Google's blacklist of suspected malware and phishing servers.",
        name="http_google_malware")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_google_malware(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-google-malware  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Spiders a website and attempts to match all pages and urls against a given string.",
        name="http_grep")
    @sk_function_context_parameter(description="Target hostname", name="host")
    @sk_function_context_parameter(
        description=
        " Returns output if there is a match for a single pattern type. ",
        name="http_grep_breakonmatch")
    @sk_function_context_parameter(
        description=
        " the string to match in urls and page contents or list of patterns separated by delimiter ",
        name="http_grep_match")
    #split
    def http_grep(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80  {context['host']}  --script http-grep --script-args='match={context['http_grep_match']},{context['http_grep_breakonmatch']}'"
        return print_str

    @sk_function(
        description=
        "Performs a HEAD request for the root folder (\"/\") of a web server and displays the HTTP headers returned.",
        name="http_headers")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_headers(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=http-headers  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Attempts to extract information from HP iLO boards including versions and addresses.",
        name="http_hp_ilo_info")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_hp_ilo_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script hp-ilo-info -sV  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Retrieves the locations of all \"Find my iPhone\" enabled iOS devices by querying the MobileMe web service (authentication required).",
        name="http_icloud_findmyiphone")
    @sk_function_context_parameter(description="the Apple Id password",
                                   name="password")
    @sk_function_context_parameter(description="the Apple Id username",
                                   name="username")
    #split
    def http_icloud_findmyiphone(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sn -Pn --script http-icloud-findmyiphone --script-args='username= {context['username']} ,password= {context['password']} '"
        return print_str

    @sk_function(
        description=
        "Sends a message to a iOS device through the Apple MobileMe web service.",
        name="http_icloud_sendmsg")
    @sk_function_context_parameter(
        default_value='http-icloud-sendmsg.listdevices',
        description=
        "list the devices managed by the specified Apple ID.Default is 'http-icloud-sendmsg.listdevices'",
        name="listdevices")
    @sk_function_context_parameter(description="the Apple ID password",
                                   name="pass")
    @sk_function_context_parameter(description="the Apple ID username",
                                   name="user")
    #split
    def http_icloud_sendmsg(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sn -Pn --script http-icloud-sendmsg --script-args=\"username= {context['user']} ,password= {context['pass']} , {context['listdevices']} \""
        return print_str

    @sk_function(description="", name="http_internal_ip_disclosure")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_internal_ip_disclosure(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-internal-ip-disclosure  {context['target']} "
        return print_str

    @sk_function(
        description="Attempts to discover JSONP endpoints in web servers.",
        name="http_jsonp_detection")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_jsonp_detection(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-internal-ip-disclosure --script-args http-internal-ip-disclosure.path={context['path']}  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Checks if the webserver allows mod_cluster management protocol (MCMP) methods.",
        name="http_mcmp")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_mcmp(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=http-mcmp  {context['target']} "
        return print_str

    @sk_function(description="Checks if the website holds a mobile version.",
                 name="http_mobileversion_checker")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_mobileversion_checker(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-mobileversion-checker.nse  {context['host']} "
        return print_str

    @sk_function(description=
                 "Spiders a website and attempts to identify open redirects.",
                 name="http_open_redirect")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_open_redirect(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-open-redirect  {context['target']} "
        return print_str

    @sk_function(
        description="Attempts to retrieve the PHP version from a web server.",
        name="http_php_version")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_php_version(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=http-php-version  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Uploads a local file to a remote web server using the HTTP PUT method.",
        name="http_put")
    @sk_function_context_parameter(description="Target ip", name="ip")
    @sk_function_context_parameter(
        description=
        " - The remote directory and filename to store the file to e.g. (/uploads/file.txt) ",
        name="http_put_url")
    #split
    def http_put(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80  {context['ip']}  --script http-put --script-args http-put.url={context['http_put_url']},http-put.file={context['ttp_put_file']}"
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve the model, firmware version, and enabled services from a QNAP Network Attached Storage (NAS) device.",
        name="http_qnap_nas_info")
    @sk_function_context_parameter(description="Target hostname", name="host")
    @sk_function_context_parameter(description="Target port", name="port")
    #split
    def http_qnap_nas_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-qnap-nas-info -p  {context['port']}   {context['host']} "
        return print_str

    @sk_function(description="Informs about cross-domain include of scripts.",
                 name="http_referer_checker")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_referer_checker(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-referer-checker.nse  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects SAP Netweaver Portal instances that allow anonymous access to the  KM unit navigation page.",
        name="http_sap_netweaver_leak")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_sap_netweaver_leak(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-sap-netweaver-leak  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Checks for the HTTP response headers related to security given in OWASP Secure Headers Project and gives a brief description of the header and its configuration value.",
        name="http_security_headers")
    @sk_function_context_parameter(description="Target port", name="port")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_security_headers(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p  {context['port']}  --script http-security-headers  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Spiders a web server and displays its directory structure along with number and types of files in each folder.",
        name="http_sitemap_generator")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_sitemap_generator(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-sitemap-generator -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Sends an HTTP TRACE request and shows if the method TRACE is enabled. If debug is enabled, it returns the header fields that were modified in the response.",
        name="http_trace")
    #split
    def http_trace(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-trace -d {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Exploits the Max-Forwards HTTP header to detect the presence of reverse proxies.",
        name="http_traceroute")
    @sk_function_context_parameter(description="Target ips and hostnames",
                                   name="targets")
    #split
    def http_traceroute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-traceroute  {context['targets']} "
        return print_str

    @sk_function(
        description=
        "Attempts to obtain information from Trane Tracer SC devices.",
        name="http_trane_info")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_trane_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script trane-info.nse  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Checks if various crawling utilities are allowed by the host.",
        name="http_useragent_tester")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def http_useragent_tester(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-useragent-tester.nse  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Searches for web virtual hostnames by making a large number of HEAD requests against http servers using common hostnames.",
        name="http_vhosts")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def http_vhosts(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vhosts -p 80,8080,443  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Connects to a VLC Streamer helper service and lists directory contents.",
        name="http_vlcstreamer_ls")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def http_vlcstreamer_ls(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 54340 --script http-vlcstreamer-ls  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Attempts to determine whether a web server is protected by an IPS (Intrusion Prevention System), IDS (Intrusion Detection System) or WAF (Web Application Firewall) by probing the web server with malicious payloads and detecting changes in the response code and body.",
        name="http_waf_detect")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(
        description=
        " Target URI. Use a path that does not redirect to a different page ",
        name="http_waf_detect_uri")
    @sk_function_context_parameter(
        description=
        " If aggro mode is set, the script will try all attack vectors to trigger the IDS/IPS/WAF ",
        name="http_waf_detect_aggro")
    #split
    def http_waf_detect(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-waf-detect --script-args=\"{context['http_waf_detect_aggro']},http-waf-detect.uri={context['http_waf_detect_uri']}\"  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tries to detect the presence of a web application firewall and its type and version.",
        name="http_waf_fingerprint")
    @sk_function_context_parameter(description="Target ips and hostnames",
                                   name="targets")
    #split
    def http_waf_fingerprint(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-waf-fingerprint  {context['targets']} "
        return print_str

    @sk_function(
        description="Enumerates themes and plugins of Wordpress installations.",
        name="http_wordpress_enum")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        default_value=100,
        description=" Number of entries or the string \"all\". Default:100. ",
        name="search_limit")
    @sk_function_context_parameter(
        default_value='false',
        description=
        " Retrieves latest plugin version information from wordpress.org. Default:false. ",
        name="check_latest")
    #split
    def http_wordpress_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-wordpress-enum --script-args check-latest={context['check_latest']},search-limit={context['search_limit']}  {context['target']} "
        return print_str

    @sk_function(
        description=
        "This script searches the xssed.com database and outputs the result.",
        name="http_xssed")
    @sk_function_context_parameter(description="Target ip and hostname",
                                   name="target")
    #split
    def http_xssed(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-xssed.nse  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Tests a list of known ICAP service names and prints information about any it detects.",
        name="icap_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def icap_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1344  {context['ip']}  --script icap-info"
        return print_str

    @sk_function(
        description="Attempts to identify IEC 60870-5-104 ICS protocol.",
        name="iec_identify")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def iec_identify(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=iec-identify  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Detects whether the remote device has ip forwarding or \"Internet connection sharing\" enabled, by sending an ICMP echo request to a given target using the scanned host as default gateway.",
        name="ip_forwarding")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        description=
        " a LAN or routed target responding to ICMP echo requests (ping). ",
        name="ip_forwarding_target")
    #split
    def ip_forwarding(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sn  {context['target']}  --script ip-forwarding --script-args='target={context['ip_forwarding_target']}'"
        return print_str

    @sk_function(
        description=
        "Tries to identify the physical location of an IP address using the Geoplugin geolocation web service.",
        name="ip_geolocation_geoplugin")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def ip_geolocation_geoplugin(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ip-geolocation-geoplugin  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Tries to identify the physical location of an IP address using the IPInfoDB geolocation web service (http://ipinfodb.com/ip_location_api.php).",
        name="ip_geolocation_ipinfodb")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        description=
        " A sting specifying the api-key which the user wants to use to access this service ",
        name="apikey")
    #split
    def ip_geolocation_ipinfodb(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ip-geolocation-ipinfodb  {context['target']}  --script-args ip-geolocation-ipinfodb.apikey={context['apikey']}"
        return print_str

    @sk_function(
        description=
        "Tries to identify the physical location of an IP address using a Geolocation Maxmind database file.",
        name="ip_geolocation_maxmind")
    @sk_function_context_parameter(description="Target ip or host",
                                   name="target")
    @sk_function_context_parameter(
        description="string indicates which file to use as a Maxmind database",
        name="maxmind_db")
    #split
    def ip_geolocation_maxmind(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ip-geolocation-maxmind  {context['target']}  [--script-args ip-geolocation.maxmind_db= {context['maxmind_db']} ]"
        return print_str

    @sk_function(
        description=
        "Classifies a host's IP ID sequence (test for susceptibility to idle scan).  Sends six probes to obtain IP IDs from the target and classifies them similarly to Nmap's method.",
        name="ipidseq")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(description="Set destination port to probe",
                                   name="probeport")
    #split
    def ipidseq(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ipidseq [--script-args probeport= {context['probeport']} ]  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Performs IPMI Information Discovery through Channel Auth probes.",
        name="ipmi_version")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def ipmi_version(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU --script ipmi-version -p 623  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Uses Multicast Listener Discovery to list the multicast addresses subscribed to by IPv6 multicast listeners on the link-local scope.",
        name="ipv6_multicast_mld_list")
    #split
    def ipv6_multicast_mld_list(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=ipv6-multicast-mld-list"
        return print_str

    @sk_function(
        description=
        "Checks an IRC server for channels that are commonly used by malicious botnets.",
        name="irc_botnet_channels")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def irc_botnet_channels(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 6667 --script=irc-botnet-channels  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Lists portals and iSCSI nodes registered with the Internet Storage Name Service (iSNS).",
        name="isns_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def isns_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3205  {context['ip']}  --script isns-info"
        return print_str

    @sk_function(
        description=
        "Discovers KNX gateways by sending a KNX Search Request to the multicast address 224.0.23.12 including a UDP payload with destination port 3671.",
        name="knx_gateway_discover")
    @sk_function_context_parameter(
        description="Interface choosed to send message.", name="interface")
    #split
    def knx_gateway_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script knx-gateway-discover -e {context['interface']}"
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve the Novell Universal Password for a user.",
        name="ldap_novell_getpass")
    @sk_function_context_parameter(
        description=" The LDAP password to use when connecting to the server ",
        name="pass")
    @sk_function_context_parameter(
        description=" The name of the account to retrieve the password for ",
        name="account")
    @sk_function_context_parameter(
        description=" The LDAP username to use when connecting to the server ",
        name="username")
    #split
    def ldap_novell_getpass(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 636 --script ldap-novell-getpass --script-args 'ldap-novell-getpass.username={context['username']}, ldap-novell-getpass.password={context['pass']}, ldap-novell-getpass.account={context['account']}'"
        return print_str

    @sk_function(
        description="Retrieves the LDAP root DSA-specific Entry (DSE)",
        name="ldap_rootdse")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def ldap_rootdse(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 389 --script ldap-rootdse  {context['host']} "
        return print_str

    @sk_function(description=
                 "Attempts to perform an LDAP search and returns all matches.",
                 name="ldap_search")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(
        description=
        " If set, specifies a quick filter. The library does not support parsing real LDAP filters. The following values are valid for the filter parameter: computer, users, ad_dcs, custom or all. If no value is specified it defaults to all. ",
        name="qfilter")
    @sk_function_context_parameter(
        description=
        " If set, the search will include only the attributes specified. For a single attribute a string value can be used, if multiple attributes need to be supplied a table should be used instead. ",
        name="attrib")
    @sk_function_context_parameter(
        description=
        " If set, the script will attempt to perform an LDAP bind using the username and password ",
        name="username")
    #split
    def ldap_search(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 389 --script ldap-search --script-args 'ldap.username={context['username']},ldap.password={context['pass']},ldap.qfilter={context['qfilter']},ldap.attrib={context['attrib']}'  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Retrieves configuration information from a Lexmark S300-S400 printer.",
        name="lexmark_config")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def lexmark_config(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 9100 --script=lexmark-config  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Resolves a hostname by using the LLMNR (Link-Local Multicast Name Resolution) protocol.",
        name="llmnr_resolve")
    @sk_function_context_parameter(
        description="Interface choosed to send message.", name="interface")
    @sk_function_context_parameter(description=" Hostname to resolve. ",
                                   name="hostname")
    #split
    def llmnr_resolve(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script llmnr-resolve --script-args 'llmnr-resolve.hostname={context['hostname']}' -e {context['interface']}"
        return print_str

    @sk_function(
        description=
        "Uses the Microsoft LLTD protocol to discover hosts on a local network.",
        name="lltd_discovery")
    @sk_function_context_parameter(
        description="Interface choosed to send message.", name="interface")
    #split
    def lltd_discovery(self, context: SKContext) -> str:
        print_str = f"sudo nmap -e {context['interface']} --script lltd-discovery"
        return print_str

    @sk_function(
        description=
        "Retrieves information (hostname, OS, uptime, etc.) from the CouchBase Web Administration port.",
        name="membase_http_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def membase_http_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8091  {context['ip']}  --script membase-http-info"
        return print_str

    @sk_function(
        description=
        "Retrieves information (including system architecture, process ID, and server time) from distributed memory object caching system memcached.",
        name="memcached_info")
    #split
    def memcached_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 11211 --script memcached-info"
        return print_str

    @sk_function(
        description=
        "Enumerates SCADA Modbus slave ids (sids) and collects their device information.",
        name="modbus_discover")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(
        description="boolean value defines find all or just first sid",
        name="aggressive")
    #split
    def modbus_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script modbus-discover.nse --script-args='modbus-discover.aggressive= {context['aggressive']} ' -p 502  {context['host']} "
        return print_str

    @sk_function(description="Dumps message traffic from MQTT brokers.",
                 name="mqtt_subscribe")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def mqtt_subscribe(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1883 --script mqtt-subscribe  {context['target']} "
        return print_str

    @sk_function(
        description="Queries targets for multicast routing information.",
        name="mrinfo")
    @sk_function_context_parameter(
        description=
        "Host to which the request is sent. If not set, the request will be sent to 224.0.0.1.",
        name="target")
    #split
    def mrinfo(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script mrinfo --script-args 'mrinfo.target= {context['target']} '"
        return print_str

    @sk_function(
        description=
        "Queries Microsoft SQL Server (ms-sql) instances for a list of databases, linked servers, and configuration settings.",
        name="ms_sql_config")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(description="user password of mysql",
                                   name="password")
    @sk_function_context_parameter(description="user name of mysql",
                                   name="username")
    #split
    def ms_sql_config(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1433 --script ms-sql-config --script-args mssql.username={context['username']},mssql.password={context['password']}  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Queries the Microsoft SQL Browser service for the DAC (Dedicated Admin Connection) port of a given (or all) SQL Server instance.",
        name="ms_sql_dac")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def ms_sql_dac(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 1434 --script ms-sql-dac  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Dumps the password hashes from an MS-SQL server in a format suitable for cracking by tools such as John-the-ripper.",
        name="ms_sql_dump_hashes")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def ms_sql_dump_hashes(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1433  {context['ip']}  --script ms-sql-dump-hashes"
        return print_str

    @sk_function(
        description=
        "Queries Microsoft SQL Server (ms-sql) instances for a list of databases a user has access to.",
        name="ms_sql_hasdbaccess")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(description="user name of mysql",
                                   name="username")
    @sk_function_context_parameter(description="user password of mysql",
                                   name="password")
    #split
    def ms_sql_hasdbaccess(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1433 --script ms-sql-hasdbaccess --script-args mssql.username={context['username']},mssql.password={context['password']}  {context['host']} "
        return print_str

    @sk_function(
        description="Runs a query against Microsoft SQL Server (ms-sql).",
        name="ms_sql_query")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(
        default_value="SELECT @@version version",
        description=
        " The query to run against the server. (default: SELECT @@version version) ",
        name="query")
    @sk_function_context_parameter(description="user name of mysql",
                                   name="username")
    @sk_function_context_parameter(description="user password of mysql",
                                   name="password")
    #split
    def ms_sql_query(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1433 --script ms-sql-query --script-args mssql.username={context['username']},mssql.password={context['password']},ms-sql-query.query={context['query']}  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Queries Microsoft SQL Server (ms-sql) for a list of tables per database.",
        name="ms_sql_tables")
    @sk_function_context_parameter(description="Target host", name="host")
    @sk_function_context_parameter(description="user name of mysql",
                                   name="username")
    @sk_function_context_parameter(description="user password of mysql",
                                   name="password")
    #split
    def ms_sql_tables(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 1433 --script ms-sql-tables --script-args mssql.username={context['username']},mssql.password={context['password']}  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Queries an MSRPC endpoint mapper for a list of mapped services and displays the gathered information.",
        name="msrpc_enum")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def msrpc_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap  {context['target']}  --script=msrpc-enum"
        return print_str

    @sk_function(
        description=
        "Queries for the multicast path from a source to a destination host.",
        name="mtrace")
    @sk_function_context_parameter(
        description=" Source address from which to traceroute. ",
        name="fromip")
    #split
    def mtrace(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script mtrace --script-args 'mtrace.fromip={context['fromip']}'"
        return print_str

    @sk_function(
        description=
        "Audits MySQL database server security configuration against parts of the CIS MySQL v1.0.2 benchmark (the engine can be used for other MySQL audits by creating appropriate audit files).",
        name="mysql_audit")
    @sk_function_context_parameter(
        description=" the password with which to connect to the database ",
        name="mysql_audit_password")
    @sk_function_context_parameter(
        description=" the username with which to connect to the database ",
        name="mysql_audit_username")
    @sk_function_context_parameter(
        description=
        " the name of the file containing the audit rulebase, \"mysql-cis.audit\" by default ",
        name="mysql_audit_filename")
    #split
    def mysql_audit(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3306 --script mysql-audit --script-args \"mysql-audit.username={context['mysql_audit_username']}, mysql-audit.password={context['mysql_audit_password']},mysql-audit.filename={context['mysql_audit_filename']}\""
        return print_str

    @sk_function(
        description="Attempts to list all databases on a MySQL server.",
        name="mysql_databases")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def mysql_databases(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=mysql-databases  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Dumps the password hashes from an MySQL server in a format suitable for cracking by tools such as John the Ripper.",
        name="mysql_dump_hashes")
    @sk_function_context_parameter(description="Target ip", name="ip")
    @sk_function_context_parameter(
        description=" the username to use to connect to the server ",
        name="username")
    @sk_function_context_parameter(
        description=" the password to use to connect to the server ",
        name="password")
    #split
    def mysql_dump_hashes(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3306  {context['ip']}  --script mysql-dump-hashes --script-args='username= {context['username']} ,password= {context['password']} '"
        return print_str

    @sk_function(
        description=
        "Runs a query against a MySQL database and returns the results as a table.",
        name="mysql_query")
    @sk_function_context_parameter(description="Target ip", name="ip")
    @sk_function_context_parameter(
        description=" the password with which to connect to the database ",
        name="password")
    @sk_function_context_parameter(
        description=" the username with which to connect to the database ",
        name="username")
    @sk_function_context_parameter(
        description=" the query for which to return the results ",
        name="query")
    #split
    def mysql_query(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3306  {context['ip']}  --script mysql-query --script-args='query=\"{context['query']}\"[,username={context['username']},password={context['password']}]'"
        return print_str

    @sk_function(
        description="Attempts to show all variables on a MySQL server.",
        name="mysql_variables")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def mysql_variables(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=mysql-variables  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Attempts to bypass authentication in MySQL and MariaDB servers by exploiting CVE2012-2122.",
        name="mysql_vuln_cve2012_2122")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def mysql_vuln_cve2012_2122(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3306 --script mysql-vuln-cve2012-2122  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Maps a WAN port on the router to a local port on the client using the NAT Port Mapping Protocol (NAT-PMP)",
        name="nat_pmp_mapport")
    @sk_function_context_parameter(description="Target ip", name="ip")
    @sk_function_context_parameter(
        description=
        " operation, can be either map, unmap or unmap all o map allows you to map an external port to an internal port of the calling IP o unmap removes the external port mapping for the specified ports and protocol o unmapall removes all mappings for the specified protocol and calling IP ",
        name="nat_pmp_mapport_op")
    @sk_function_context_parameter(
        description=" the protocol to map, can be either tcp or udp. ",
        name="nat_pmp_mapport_protocol")
    @sk_function_context_parameter(
        description=
        " the internal port of the calling IP to map requests to. This port will receive all requests coming in to the external port on the router. ",
        name="nat_pmp_mapport_privport")
    @sk_function_context_parameter(
        description=
        " the external port to map on the router. The specified port is treated as the requested port. If the port is available it will be allocated to the caller, otherwise the router will simply choose another port, create the mapping and return the resulting port. ",
        name="nat_pmp_mapport_pubport")
    #split
    def nat_pmp_mapport(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 5351  {context['ip']}  --script nat-pmp-mapport --script-args='op={context['nat_pmp_mapport_op']},pubport={context['nat_pmp_mapport_pubport']},privport={context['nat_pmp_mapport_privport']},protocol={context['nat_pmp_mapport_protocol']}'"
        return print_str

    @sk_function(
        description=
        "Displays protocol and block device information from NBD servers.",
        name="nbd_info")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def nbd_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 10809 --script nbd-info  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Lists remote file systems by querying the remote device using the Network Data Management Protocol (ndmp).",
        name="ndmp_fs_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def ndmp_fs_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 10000 --script ndmp-fs-info  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Attempts to get useful information about files from NFS exports.",
        name="nfs_ls")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def nfs_ls(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 111 --script=nfs-ls  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Shows NFS exports, like the <code>showmount -e</code> command.",
        name="nfs_showmount")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def nfs_showmount(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=nfs-showmount  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Retrieves disk space statistics and information from a remote NFS share.",
        name="nfs_statfs")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def nfs_statfs(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 111 --script=nfs-statfs  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Queries Nagios Remote Plugin Executor (NRPE) daemons to obtain information such as load averages, process counts, logged in user information, etc.",
        name="nrpe_enum")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def nrpe_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nrpe-enum -p 5666  {context['host']} "
        return print_str

    @sk_function(
        description="Obtains and prints an NTP server's monitor data.",
        name="ntp_monlist")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def ntp_monlist(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -pU:123 -Pn -n --script=ntp-monlist  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve the list of target systems and networks from an OpenVAS Manager server.",
        name="omp2_enum_targets")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def omp2_enum_targets(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 9390 --script omp2-brute,omp2-enum-targets  {context['target']} "
        return print_str

    @sk_function(
        description=
        "This NSE script is used to send a FINS packet to a remote device.",
        name="omron_info")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def omron_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script omron-info -sU -p 9600  {context['host']} "
        return print_str

    @sk_function(
        description=
        "OpenWebNet is a communications protocol developed by Bticino since 2000. Retrieves device identifying information and number of connected devices.",
        name="openwebnet_discovery")
    #split
    def openwebnet_discovery(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script openwebnet-discovery"
        return print_str

    @sk_function(
        description="Performs simple Path MTU Discovery to target hosts.",
        name="path_mtu")
    #split
    def path_mtu(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script path-mtu target"
        return print_str

    @sk_function(
        description=
        "This NSE script will query and parse pcworx protocol to a remote PLC.",
        name="pcworx_info")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def pcworx_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script pcworx-info -p 1962  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Repeatedly probe open and/or closed ports on a host to obtain a series of round-trip time values for each port.",
        name="qscan")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        description=
        " Confidence level: 0.75 , 0.9 , 0.95 , 0.975 , 0.99 , 0.995 , or 0.9995 . ",
        name="confidence")
    @sk_function_context_parameter(
        description=" Number of round-trip times to try to get. ",
        name="numtrips")
    @sk_function_context_parameter(
        default_value="200",
        description=
        " Average delay between packet sends. This is a number followed by ms for milliseconds or s for seconds. ( m and h are also supported but are too long for timeouts.) The actual delay will randomly vary between 50% and 150% of the time specified. Default: 200ms . ",
        name="delay")
    #split
    def qscan(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script qscan --script-args qscan.confidence= {context['confidence']} ,qscan.delay= {context['delay']} ,qscan.numtrips= {context['numtrips']}   {context['target']} "
        return print_str

    @sk_function(
        description=
        "Determines which Security layer and Encryption level is supported by the RDP service.",
        name="rdp_enum_encryption")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def rdp_enum_encryption(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3389 --script rdp-enum-encryption  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Retrieves information (such as version number and architecture) from a Redis key-value store.",
        name="redis_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def redis_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 6379  {context['ip']}  --script redis-info"
        return print_str

    @sk_function(
        description=
        "This script has been replaced by the <code>--resolve-all</code> command-line option in Nmap 7.70  Resolves hostnames and adds every address (IPv4 or IPv6, depending on Nmap mode) to Nmap's target list.",
        name="resolveall")
    @sk_function_context_parameter(
        description=" Table of hostnames to resolve ", name="resolveall_hosts")
    @sk_function_context_parameter(
        description=" See the documentation for the target library. ",
        name="newtargets")
    #split
    def resolveall(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=resolveall --script-args={context['newtargets']},resolveall.hosts={context['resolveall_hosts']}"
        return print_str

    @sk_function(
        description="Retrieves the day and time from the Time service.",
        name="rfc868_time")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def rfc868_time(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Retrieves information (such as node name and architecture) from a Basho Riak distributed database using the HTTP protocol.",
        name="riak_http_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def riak_http_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8098  {context['ip']}  --script riak-http-info"
        return print_str

    @sk_function(
        description=
        "Connects to the rpcap service (provides remote sniffing capabilities through WinPcap) and retrieves interface information.",
        name="rpcap_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def rpcap_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2002  {context['ip']}  --script rpcap-info"
        return print_str

    @sk_function(
        description=
        "Lists modules available for rsync (remote file sync) synchronization.",
        name="rsync_list_modules")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def rsync_list_modules(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 873 --script rsync-list-modules  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Connects to rusersd RPC service and retrieves a list of logged-in users.",
        name="rusers")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def rusers(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=rusers  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Enumerates Siemens S7 PLC Devices and collects their device information.",
        name="s7_info")
    @sk_function_context_parameter(description="Target hostname", name="hosts")
    #split
    def s7_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script s7-info.nse -p 102  {context['hosts']} "
        return print_str

    @sk_function(
        description=
        "Queries Shodan API for given targets and produces similar output to a -sV nmap scan.",
        name="shodan_api")
    @sk_function_context_parameter(
        description="Specify a single target to be scanned.", name="target")
    @sk_function_context_parameter(
        description=
        " Specify the ShodanAPI key. This can also be hardcoded in the nse file. ",
        name="apikey")
    #split
    def shodan_api(self, context: SKContext) -> str:
        print_str = f" nmap --script shodan-api --script-args 'shodan-api.target= {context['target']} ,shodan-api.apikey={context['apikey']}'"
        return print_str

    @sk_function(
        description=
        "Spoofs a call to a SIP phone and detects the action taken by the target (busy, declined, hung up, etc.)",
        name="sip_call_spoof")
    @sk_function_context_parameter(description="Target ips and hostnames",
                                   name="targets")
    #split
    def sip_call_spoof(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=sip-call-spoof -sU -p 5060  {context['targets']} "
        return print_str

    @sk_function(
        description=
        "Attempts to list the supported capabilities in a SMBv2 server for each  enabled dialect.",
        name="smb2_capabilities")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def smb2_capabilities(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445 --script smb2-capabilities  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate domains on a system, along with their policies",
        name="smb_enum_domains")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_enum_domains(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-domains.nse -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Obtains a list of groups from the remote Windows system, as well as a list of the group's users.",
        name="smb_enum_groups")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_enum_groups(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-users.nse -p 445  {context['host']} "
        return print_str

    @sk_function(description=
                 "Pulls a list of processes from the remote server over SMB.",
                 name="smb_enum_processes")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_enum_processes(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-processes.nse -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Retrieves the list of services running on a remote Windows system.",
        name="smb_enum_services")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_enum_services(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-services.nse -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Enumerates the users logged into a system either locally or through an SMB share.",
        name="smb_enum_sessions")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_enum_sessions(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-sessions.nse -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to list shares using the <code>srvsvc.NetShareEnumAll</code> MSRPC function and retrieve more information about them using <code>srvsvc.NetShareGetInfo</code>. ",
        name="smb_enum_shares")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_enum_shares(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-shares.nse -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve useful information about files shared on SMB volumes. The output is intended to resemble the output of the UNIX <code>ls</code> command.",
        name="smb_ls")
    @sk_function_context_parameter(description="Target ip", name="ip")
    @sk_function_context_parameter(
        default_value="root",
        description=
        " the path, relative to the share to list the contents from (default: root of the share) ",
        name="smb_ls_path")
    @sk_function_context_parameter(
        description=
        " (or smb-ls.shares) the share (or a colon-separated list of shares) to connect to (default: use shares found by smb-enum-shares) ",
        name="smb_ls_share")
    #split
    def smb_ls(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445  {context['ip']}  --script smb-ls --script-args 'share={context['smb_ls_share']},path={context['smb_ls_path']}'"
        return print_str

    @sk_function(description=
                 "Queries information managed by the Windows Master Browser.",
                 name="smb_mbenum")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_mbenum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445  {context['host']}  --script smb-mbenum"
        return print_str

    @sk_function(
        description=
        "Attempts to list the supported protocols and dialects of a SMB server. ",
        name="smb_protocols")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def smb_protocols(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445 --script smb-protocols  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Attempts to grab the server's statistics over SMB and MSRPC, which uses TCP ports 445 or 139. ",
        name="smb_server_stats")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_server_stats(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-server-stats.nse -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Pulls back information about the remote system from the registry. ",
        name="smb_system_info")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def smb_system_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-system-info.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to relay mail by issuing a predefined combination of SMTP commands. The goal of this script is to tell if a SMTP server is vulnerable to mail relaying. ",
        name="smtp_open_relay")
    @sk_function_context_parameter(description="Target hostname", name="host")
    @sk_function_context_parameter(
        description=
        "Use this to change the IP address to be used (default is the target IP address)",
        name="ip")
    @sk_function_context_parameter(
        default_value="nmap.scanme.org",
        description=
        " or smtp-open-relay.domain Define the domain to be used in the anti-spam tests and EHLO command (default is nmap.scanme.org) ",
        name="domain")
    #split
    def smtp_open_relay(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smtp-open-relay.nse [--script-args smtp-open-relay.domain={context['domain']},smtp-open-relay.ip= {context['ip']} ] -p 25,465,587  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks if a target on a local Ethernet has its network card in promiscuous mode.",
        name="sniffer_detect")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def sniffer_detect(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=sniffer-detect  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Reports the number of algorithms (for encryption, compression, etc.) that the target SSH2 server offers. If verbosity is set, the offered algorithms are each listed by type.  If the \"client to server\" and \"server to client\" algorithm lists are identical (order specifies preference) then the list is shown only once under a combined type.",
        name="ssh2_enum_algos")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def ssh2_enum_algos(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ssh2-enum-algos  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Reports any private (RFC1918) IPv4 addresses found in the various fields of an SSL service's certificate.  These will only be reported if the target address itself is not private.  Nmap v7.30 or later is required.",
        name="ssl_cert_intaddr")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def ssl_cert_intaddr(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-cert-intaddr  {context['target']} "
        return print_str

    @sk_function(
        description=
        "This script repeatedly initiates SSLv3/TLS connections, each time trying a new cipher or compressor while recording whether a host accepts or rejects it. ",
        name="ssl_enum_ciphers")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def ssl_enum_ciphers(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script ssl-enum-ciphers -p 443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Retrieves the external IP address of a NAT:ed host using the STUN protocol.",
        name="stun_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def stun_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV -PN -sU -p 3478 --script stun-info  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Detects whether a host is infected with the Stuxnet worm.  An executable version of the Stuxnet infection will be downloaded if a format for the filename is given on the command line.",
        name="stuxnet_detect")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def stuxnet_detect(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script stuxnet-detect -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Produces a list of IP prefixes for a given routing AS number (ASN).  This script uses a whois server database operated by the Shadowserver Foundation. ",
        name="targets_asn")
    @sk_function_context_parameter(description=" The ASN to search. ",
                                   name="targets_asn_asn")
    #split
    def targets_asn(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script targets-asn --script-args targets-asn.asn={context['targets_asn_asn']}"
        return print_str

    @sk_function(
        description=
        "This script runs in the pre-scanning phase to map IPv4 addresses onto IPv6 networks and add them to the scan queue.  The technique is more general than what is technically termed \"IPv4-mapped IPv6 addresses.\" The lower 4 bytes of the IPv6 network address are replaced with the 4 bytes of IPv4 address. When the IPv6 network is ::ffff:0:0/96, then the script generates IPv4-mapped IPv6 addresses. When the network is ::/96, then it generates IPv4-compatible IPv6 addresses.",
        name="targets_ipv6_map4to6")
    @sk_function_context_parameter(
        description=
        " This must have at least one IPv4 Host for the script be able to work (Ex. 192.168.1.1 or { 192.168.1.1, 192.168.2.2 } ) or Subnet Addresses ( 192.168.1.0/24 or { 192.168.1.0/24, 192.168.2.0/24 } ) ",
        name="IPv4Hosts")
    @sk_function_context_parameter(
        description=
        " Table/single IPv6 address with prefix (Ex. 2001:db8:c0ca::/48 or { 2001:db8:c0ca::/48, 2001:db8:FEA::/48 }) ",
        name="targets_ipv6_subnet")
    @sk_function_context_parameter(
        description=" See the documentation for the target library. ",
        name="newtargets")
    #split
    def targets_ipv6_map4to6(self, context: SKContext) -> str:
        print_str = f"sudo nmap -6 --script targets-ipv6-map4to6 --script-args {context['newtargets']},targets-ipv6-map4to6.IPv4Hosts={context['IPv4Hosts']},targets-ipv6-subnet={context['targets_ipv6_subnet']}"
        return print_str

    @sk_function(
        description=
        "Sends an ICMPv6 echo request packet to the all-nodes link-local multicast address (ff02::1) to discover responsive hosts on a LAN without needing to individually ping each IPv6 address.",
        name="targets_ipv6_multicast_echo")
    @sk_function_context_parameter(
        description=" If true, add discovered targets to the scan queue. ",
        name="newtargets")
    @sk_function_context_parameter(
        description=" The interface to use for host discovery. ",
        name="targets_ipv6_multicast_echo_interface")
    #split
    def targets_ipv6_multicast_echo(self, context: SKContext) -> str:
        print_str = f"./nmap -6 --script=targets-ipv6-multicast-echo.nse --script-args ' {context['newtargets']} ,interface={context['targets_ipv6_multicast_echo_interface']}' -sL"
        return print_str

    @sk_function(
        description=
        "Sends an ICMPv6 packet with an invalid extension header to the all-nodes link-local multicast address (<code>ff02::1</code>) to discover (some) available hosts on the LAN. This works because some hosts will respond to this probe with an ICMPv6 Parameter Problem packet.",
        name="targets_ipv6_multicast_invalid_dst")
    @sk_function_context_parameter(
        description=" If true, add discovered targets to the scan queue. ",
        name="newtargets")
    @sk_function_context_parameter(
        description=" The interface to use for host discovery. ",
        name="interface")
    #split
    def targets_ipv6_multicast_invalid_dst(self, context: SKContext) -> str:
        print_str = f"./nmap -6 --script=targets-ipv6-multicast-invalid-dst.nse --script-args ' {context['newtargets']} ,interface={context['interface']}' -sP"
        return print_str

    @sk_function(
        description=
        "Attempts to discover available IPv6 hosts on the LAN by sending an MLD (multicast listener discovery) query to the link-local multicast address (ff02::1) and listening for any responses.  The query's maximum response delay set to 1 to provoke hosts to respond immediately rather than waiting for other responses from their multicast group.",
        name="targets_ipv6_multicast_mld")
    @sk_function_context_parameter(
        default_value=
        "the interface specified with -e or every available Ethernet interface with an IPv6 address.) ",
        description=
        " Interface to send on (default: the interface specified with -e or every available Ethernet interface with an IPv6 address.) ",
        name="targets_ipv6_multicast_mld_interface")
    @sk_function_context_parameter(
        description=" See the documentation for the target library. ",
        name="newtargets")
    #split
    def targets_ipv6_multicast_mld(self, context: SKContext) -> str:
        print_str = f"sudo nmap -6 --script=targets-ipv6-multicast-mld.nse --script-args '{context['newtargets']},interface={context['targets_ipv6_multicast_mld_interface']}'"
        return print_str

    @sk_function(
        description=
        "Performs IPv6 host discovery by triggering stateless address auto-configuration (SLAAC).",
        name="targets_ipv6_multicast_slaac")
    @sk_function_context_parameter(
        description=" The interface to use for host discovery. ",
        name="targets_ipv6_multicast_slaac_interface")
    @sk_function_context_parameter(
        description=" See the documentation for the target library. ",
        name="newtargets")
    #split
    def targets_ipv6_multicast_slaac(self, context: SKContext) -> str:
        print_str = f"sudo nmap -6 --script targets-ipv6-multicast-slaac --script-args '{context['newtargets']},interface={context['targets_ipv6_multicast_slaac_interface']}' -sP"
        return print_str

    @sk_function(
        description=
        "Adds IPv6 addresses to the scan queue using a wordlist of hexadecimal \"words\" that form addresses in a given subnet.",
        name="targets_ipv6_wordlist")
    @sk_function_context_parameter(
        description=
        " table/single IPv6 address with prefix (Ex. 2001:db8:c0ca::/48 or { 2001:db8:c0ca::/48, 2001:db8:FEA::/48 } ) ",
        name="targets_ipv6_subnet")
    @sk_function_context_parameter(
        description=" See the documentation for the target library. ",
        name="newtargets")
    #split
    def targets_ipv6_wordlist(self, context: SKContext) -> str:
        print_str = f"sudo nmap -6 -p 80 --script targets-ipv6-wordlist --script-args {context['newtargets']},targets-ipv6-subnet={context['targets_ipv6_subnet']}"
        return print_str

    @sk_function(
        description=
        "Sniffs the local network for a configurable amount of time (10 seconds by default) and prints discovered addresses. If the <code>newtargets</code> script argument is set, discovered addresses are added to the scan queue.  Requires root privileges. Either the <code>targets-sniffer.iface</code> script argument or <code>-e</code> Nmap option to define which interface to use.",
        name="targets_sniffer")
    @sk_function_context_parameter(
        description=" The interface to use for sniffing. ", name="iface")
    @sk_function_context_parameter(
        default_value="10s . ",
        description=" The amount of time to listen for packets. Default 10s . ",
        name="timeout")
    @sk_function_context_parameter(
        description=" If true, add discovered targets to the scan queue. ",
        name="newtargets")
    #split
    def targets_sniffer(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sL --script=targets-sniffer --script-args= {context['newtargets']} ,targets-sniffer.timeout={context['timeout']},targets-sniffer.iface={context['iface']}"
        return print_str

    @sk_function(
        description=
        "Inserts traceroute hops into the Nmap scanning queue. It only functions if Nmap's <code>--traceroute</code> option is used and the <code>newtargets</code> script argument is given.",
        name="targets_traceroute")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    @sk_function_context_parameter(
        description=
        " If specified, adds traceroute hops onto Nmap scanning queue. ",
        name="newtargets")
    #split
    def targets_traceroute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script targets-traceroute --script-args  {context['newtargets']}  --traceroute  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Determines whether the encryption option is supported on a remote telnet server.  Some systems (including FreeBSD and the krb5 telnetd available in many Linux distributions) implement this option incorrectly, leading to a remote root vulnerability. This script currently only tests whether encryption is supported, not for that particular vulnerability.",
        name="telnet_encryption")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def telnet_encryption(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 23  {context['ip']}  --script telnet-encryption"
        return print_str

    @sk_function(
        description=
        "Enumerates TFTP (trivial file transfer protocol) filenames by testing for a list of common ones.  ",
        name="tftp_enum")
    @sk_function_context_parameter(description="Target hostname", name="host")
    @sk_function_context_parameter(
        description=
        "file name with list of filenames to enumerate at tftp server",
        name="filelist")
    #split
    def tftp_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 69 --script tftp-enum.nse --script-args tftp-enum.filelist= {context['filelist']}   {context['host']} "
        return print_str

    @sk_function(
        description=
        "Connects to a tn3270 'server' and returns the screen.  Hidden fields will be listed below the screen with (row, col) coordinates.",
        name="tn3270_screen")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def tn3270_screen(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script tn3270-info,tn3270_screen  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Lists the geographic locations of each hop in a traceroute and optionally saves the results to a KML file, plottable on Google earth and maps.",
        name="traceroute_geolocation")
    #split
    def traceroute_geolocation(self, context: SKContext) -> str:
        print_str = f"sudo nmap --traceroute --script traceroute-geolocation"
        return print_str

    @sk_function(
        description=
        "Extracts information, including file paths, version and database names from a Versant object database.",
        name="versant_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def versant_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 5019  {context['ip']}  --script versant-info"
        return print_str

    @sk_function(
        description=
        "Queries VMware server (vCenter, ESX, ESXi) SOAP API to extract the version information. ",
        name="vmware_version")
    @sk_function_context_parameter(description="Target hostname", name="host")
    #split
    def vmware_version(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script vmware-version -p 443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tries to log into a VNC server and get its desktop name. Uses credentials discovered by vnc-brute, or None authentication types. If <code>realvnc-auth-bypass</code> was run and returned VULNERABLE, this script will use that vulnerability to bypass authentication.",
        name="vnc_title")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def vnc_title(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=vnc-title  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Retrieves cluster and store information from the Voldemort distributed key-value store using the Voldemort Native Protocol.",
        name="voldemort_info")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def voldemort_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 6666 --script voldemort-info  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Retrieves some basic information, including protocol version from a Vuze filesharing node.  As Vuze doesn't have a default port for its DHT service, this script has some difficulties in determining when to run. Most scripts are triggered by either a default port or a fingerprinted service. To get around this, there are two options: 1. Always run a version scan, to identify the vuze-dht service in order to    trigger the script. 2. Force the script to run against each port by setting the argument    vuze-dht-info.allports",
        name="vuze_dht_info")
    @sk_function_context_parameter(description="Target port", name="port")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def vuze_dht_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p  {context['port']}   {context['ip']}  --script vuze-dht-info -sV"
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve information about the domain name of the target",
        name="whois_domain")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def whois_domain(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script whois-domain.nse  {context['target']} "
        return print_str

    @sk_function(
        description=
        "Queries the WHOIS services of Regional Internet Registries (RIR) and attempts to retrieve information about the IP Address Assignment which contains the Target IP Address.",
        name="whois_ip")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def whois_ip(self, context: SKContext) -> str:
        print_str = f"sudo nmap  {context['target']}  --script whois-ip"
        return print_str

    @sk_function(
        description=
        "Requests an XDMCP (X display manager control protocol) session and lists supported authentication and authorization mechanisms.",
        name="xdmcp_discover")
    @sk_function_context_parameter(description="Target ip", name="ip")
    #split
    def xdmcp_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 177 --script xdmcp-discover  {context['ip']} "
        return print_str

    @sk_function(description="", name="broadcast_avahi_dos")
    #split
    def broadcast_avahi_dos(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=broadcast-avahi-dos"
        return print_str

    @sk_function(
        description=
        "Performs brute force passwords auditing against the Apache JServ protocol. The Apache JServ Protocol is commonly used by web servers to communicate with back-end Java application server containers.",
        name="ajp_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ajp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8009  {context['ip']}  --script ajp-brute"
        return print_str

    @sk_function(
        description=
        "Detects the Mac OS X AFP directory traversal vulnerability, CVE-2010-0533.  This script attempts to iterate over all AFP shares on the remote host.",
        name="afp_path_vuln")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def afp_path_vuln(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 8009  {context['ip']}  --script ajp-brute"
        return print_str

    @sk_function(
        description=
        "Performs password guessing against Apple Filing Protocol (AFP).",
        name="afp_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def afp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 548 --script afp-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Exploits a directory traversal vulnerability in Apache Axis2 version 1.4.1 by sending a specially crafted request to the parameter <code>xsd</code> (BID 40343).",
        name="http_axis2_dir_traversal")
    #split
    def http_axis2_dir_traversal(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80,8080 --script http-axis2-dir-traversal --script-args 'http-axis2-dir-traversal.file=../../../../../../../etc/issue' <host/ip>"
        return print_str

    @sk_function(
        description=
        "Checks for a stack-based buffer overflow in the ProFTPD server, version between 1.3.2rc3 and 1.3.3b. By sending a large number of TELNET_IAC escape sequence, the proftpd process miscalculates the buffer length, and a remote attacker will be able to corrupt the stack and execute arbitrary code within the context of the proftpd process (CVE-2010-4221). Authentication is not required to exploit this vulnerability. ",
        name="ftp_vuln_cve2010_4221")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ftp_vuln_cve2010_4221(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ftp-vuln-cve2010-4221 -p 21  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tests for the presence of the vsFTPd 2.3.4 backdoor reported on 2011-07-04 (CVE-2011-2523). This script attempts to exploit the backdoor using the innocuous <code>id</code> command by default, but that can be changed with the <code>exploit.cmd</code> or <code>ftp-vsftpd-backdoor.cmd</code> script arguments. ",
        name="ftp_vsftpd_backdoor")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ftp_vsftpd_backdoor(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ftp-vsftpd-backdoor -p 21  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tests for the presence of the ProFTPD 1.3.3c backdoor reported as BID 45150. This script attempts to exploit the backdoor using the innocuous <code>id</code> command by default, but that can be changed with the <code>ftp-proftpd-backdoor.cmd</code> script argument.",
        name="ftp_proftpd_backdoor")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ftp_proftpd_backdoor(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ftp-proftpd-backdoor -p 21  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks if an FTPd is prone to CVE-2010-1938 (OPIE off-by-one stack overflow). Be advised that, if launched against a vulnerable host, this script will crash the FTPd.",
        name="ftp_libopie")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ftp_libopie(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ftp-proftpd-backdoor -p 21  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against FTP servers. ",
        name="ftp_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ftp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ftp-brute -p 21  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects a vulnerability in netfilter and other firewalls that use helpers to dynamically open ports for protocols such as ftp and sip.  The script works by spoofing a packet from the target server asking for opening a related connection to a target port which will be fulfilled by the firewall through the adequate protocol helper port. The attacking machine should be on the same network segment as the firewall for this to work. The script supports ftp helper on both IPv4 and IPv6. Real path filter is used to prevent such attacks. ",
        name="firewall_bypass")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def firewall_bypass(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script firewall-bypass {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs password guessing against databases supporting the IBM DB2 protocol such as Informix, DB2 and Derby",
        name="drda_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def drda_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 50000 --script drda-brute {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against an iPhoto Library.",
        name="dpap_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def dpap_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script dpap-brute -p 8770  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against XMPP (Jabber) instant messaging servers.",
        name="xmpp_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def xmpp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 5222 --script xmpp-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Many mainframes use VTAM screens to connect to various applications (CICS, IMS, TSO, and many more).  This script attempts to brute force those VTAM application IDs.  This script is based on mainframe_brute by Dominic White. However, this script doesn't rely on any third party libraries or tools and instead uses the NSE TN3270 library which emulates a TN3270 screen in lua.  Application IDs only allows for 8 byte IDs, that is the only specific rule found for application IDs.",
        name="vtam_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def vtam_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script vtam-enum -p 23 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tries to log into a VNC server and get its desktop name. Uses credentials discovered by vnc-brute, or None authentication types. If <code>realvnc-auth-bypass</code> was run and returned VULNERABLE, this script will use that vulnerability to bypass authentication.",
        name="vnc_title")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def vnc_title(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script vtam-enum -p 23 {context['ip']}"
        return print_str

    @sk_function(description=
                 "Performs brute force password auditing against VNC servers.",
                 name="vnc_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def vnc_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script vnc-brute -p 5900  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the VMWare Authentication Daemon (vmware-authd).",
        name="vmauthd_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def vmauthd_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 902  {context['ip']}  --script vmauthd-brute"
        return print_str

    @sk_function(
        description=
        "TSO User ID enumerator for IBM mainframes (z/OS). The TSO logon panel tells you when a user ID is valid or invalid with the message:  <code>IKJ56420I Userid <user ID> not authorized to use TSO</code>.  The TSO logon process can work in two ways: 1) You get prompted with <code>IKJ56700A ENTER USERID -</code>    to which you reply with the user you want to use.    If the user ID is valid it will give you a normal    TSO logon screen. Otherwise it will give you the    screen logon error above. 2) You're given the TSO logon panel and enter your user ID    at the <code>Userid    ===></code> prompt. If you give    it an invalid user ID you receive the error message above.  This script relies on the NSE TN3270 library which emulates a TN3270 screen for NMAP.  TSO user IDs have the following rules:  - it cannot begin with a number  - only contains alpha-numeric characters and @, #, $.  - it cannot be longer than 7 chars",
        name="tso_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def tso_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=tso-enum -p 23 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "TSO account brute forcer.  This script relies on the NSE TN3270 library which emulates a TN3270 screen for NMAP.  TSO user IDs have the following rules:  - it cannot begin with a number  - only contains alpha-numeric characters and @, #, $.  - it cannot be longer than 7 chars",
        name="tso_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def tso_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2401 --script tso-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Enumerates TFTP (trivial file transfer protocol) filenames by testing for a list of common ones.  TFTP doesn't provide directory listings. This script tries to retrieve filenames from a list. The list is composed of static names from the file <code>tftplist.txt</code>, plus configuration filenames for Cisco devices that change based on the target address, of the form <code>A.B.C.X-confg</code> for an IP address A.B.C.D and for X in 0 to 255.  Use the <code>tftp-enum.filelist</code> script argument to search for other static filenames. ",
        name="tftp_enum")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def tftp_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2401 --script tso-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute-force password auditing against telnet servers.",
        name="telnet_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def telnet_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 23 --script telnet-brute --script-args userdb=myusers.lst,passdb=mypwds.lst,telnet-brute.timeout=8s {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against Subversion source code control servers.",
        name="svn_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def svn_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script svn-brute --script-args svn-brute.repo=/svn/ -p 3690  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects whether a host is infected with the Stuxnet worm.  An executable version of the Stuxnet infection will be downloaded if a format for the filename is given on the command line.",
        name="stuxnet_detect")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def stuxnet_detect(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script stuxnet-detect -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Determines whether the server supports SSLv2, what ciphers it supports and tests for CVE-2015-3197, CVE-2016-0703 and CVE-2016-0800 (DROWN)",
        name="sslv2_drown")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def sslv2_drown(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script stuxnet-detect -p 445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "This script repeatedly initiates SSLv3/TLS connections, each time trying a new cipher or compressor while recording whether a host accepts or rejects it. ",
        name="ssl_enum_ciphers")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ssl_enum_ciphers(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script ssl-enum-ciphers -p 443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Runs remote command on ssh server and returns command output.",
        name="ssh_run")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ssh_run(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script ssl-enum-ciphers -p 443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "This script takes a table of paths to private keys, passphrases, and usernames and checks each pair to see if the target ssh server accepts them for publickey authentication. If no keys are given or the known-bad option is given, the script will check if a list of known static public keys are accepted for authentication.",
        name="ssh_publickey_acceptance")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        description=" Table containing usernames to check ",
        name="ssh_usernames")
    #split
    def ssh_publickey_acceptance(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 22 --script ssh-publickey-acceptance --script-args \"ssh.usernames={context['ssh_usernames']}, ssh.privatekeys={'./id_rsa1', './id_rsa2'}\"  {context['ip']}"
        return print_str

    @sk_function(description=
                 "Performs brute-force password guessing against ssh servers.",
                 name="ssh_brute")
    #split
    def ssh_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst "
        return print_str

    @sk_function(
        description=
        "Returns authentication methods that a SSH server supports.  This is in the \"intrusive\" category because it starts an authentication with a username which may be invalid. The abandoned connection will likely be logged.",
        name="ssh_auth_methods")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ssh_auth_methods(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 22 --script ssh-auth-methods --script-args=\"ssh.user=<username>\" {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against SOCKS 5 proxy servers.",
        name="socks_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def socks_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script socks-brute -p 1080  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to downloads Cisco router IOS configuration files using SNMP RW (v1) and display or save them.",
        name="snmp_ios_config")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def snmp_ios_config(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 161 --script snmp-ios-config --script-args creds.snmp=:<community> {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to find an SNMP community string by brute force guessing.  This script opens a sending socket and a sniffing pcap socket in parallel threads. The sending socket sends the SNMP probes with the community strings, while the pcap socket sniffs the network for an answer to the probes. If valid community strings are found, they are added to the creds database and reported in the output.  The script takes the <code>snmp-brute.communitiesdb</code> argument that allows the user to define the file that contains the community strings to be used. If not defined, the default wordlist used to bruteforce the SNMP community strings is <code>nselib/data/snmpcommunities.lst</code>. In case this wordlist does not exist, the script falls back to <code>nselib/data/passwords.lst</code>  No output is reported if no valid account is found.",
        name="snmp_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def snmp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU --script snmp-brute {context['ip']} [--script-args snmp-brute.communitiesdb=<wordlist> ]"
        return print_str

    @sk_function(
        description=
        "Checks if a target on a local Ethernet has its network card in promiscuous mode. ",
        name="sniffer_detect")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def sniffer_detect(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU --script snmp-brute {context['ip']} [--script-args snmp-brute.communitiesdb=<wordlist> ]"
        return print_str

    @sk_function(
        description=
        "Checks for a format string vulnerability in the Exim SMTP server (version 4.70 through 4.75) with DomainKeys Identified Mail (DKIM) support (CVE-2011-1764).  The DKIM logging mechanism did not use format string specifiers when logging some parts of the DKIM-Signature header field. A remote attacker who is able to send emails, can exploit this vulnerability and execute arbitrary code with the privileges of the Exim daemon. ",
        name="smtp_vuln_cve2011_1764")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smtp_vuln_cve2011_1764(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=smtp-vuln-cve2011-1764 -pT:25,465,587  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks for a memory corruption in the Postfix SMTP server when it uses Cyrus SASL library authentication mechanisms (CVE-2011-1720).  This vulnerability can allow denial of service and possibly remote code execution. ",
        name="smtp_vuln_cve2011_1720")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smtp_vuln_cve2011_1720(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=smtp-vuln-cve2011-1720 --script-args='smtp.domain=<domain>' -pT:25,465,587  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks for and/or exploits a heap overflow within versions of Exim prior to version 4.69 (CVE-2010-4344) and a privilege escalation vulnerability in Exim 4.72 and prior (CVE-2010-4345).",
        name="smtp_vuln_cve2010_4344")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smtp_vuln_cve2010_4344(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=smtp-vuln-cve2010-4344 --script-args=\"smtp-vuln-cve2010-4344.exploit\" -pT:25,465,587  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to relay mail by issuing a predefined combination of SMTP commands. The goal of this script is to tell if a SMTP server is vulnerable to mail relaying.",
        name="smtp_open_relay")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smtp_open_relay(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smtp-open-relay.nse [--script-args smtp-open-relay.domain=<domain>,smtp-open-relay.ip=<address>,...] -p 25,465,587  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate the users on a SMTP server by issuing the VRFY, EXPN or RCPT TO commands. ",
        name="smtp_enum_users")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    @sk_function_context_parameter(
        description=
        " Define the methods and order to be used by the script (EXPN, VRFY, RCPT) ",
        name="smtp_enum_users_methods")
    #split
    def smtp_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smtp-enum-users.nse [--script-args smtp-enum-users.methods={context['smtp_enum_users_methods']},...] -p 25,465,587  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against SMTP servers using either LOGIN, PLAIN, CRAM-MD5, DIGEST-MD5 or NTLM authentication.",
        name="smtp_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smtp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 25 --script smtp-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to run a command via WebExService, using the WebExec vulnerability. Given a Windows account (local or domain), this will start an arbitrary executable with SYSTEM privileges over the SMB protocol.  The argument webexec_command will run the command directly. It may or may not start with a GUI. webexec_gui_command will always start with a GUI, and is useful for running commands such as \"cmd.exe\" as SYSTEM if you have access. ",
        name="smb_webexec_exploit")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_webexec_exploit(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-webexec --script-args 'smbusername=<username>,smbpass=<password>,webexec_command=net user test test /add' -p139,445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks whether the WebExService is installed and allows us to run code.  Note: Requires a user account (local or domain). ",
        name="smb_vuln_webexec")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_webexec(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-webexec --script-args smbusername=<username>,smbpass=<password> -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks if a Microsoft Windows 2000 system is vulnerable to a crash in regsvc caused by a null pointer dereference. This check will crash the service if it is vulnerable and requires a guest account or higher to work. This check was previously part of smb-check-vulns.",
        name="smb_vuln_regsvc_dos")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_regsvc_dos(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-regsvc-dos.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tests whether target machines are vulnerable to ms10-061 Printer Spooler impersonation vulnerability.",
        name="smb_vuln_ms10_061")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_ms10_061(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-regsvc-dos.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tests whether target machines are vulnerable to the ms10-054 SMB remote memory corruption vulnerability.  The vulnerable machine will crash with BSOD.  The script requires at least READ access right to a share on a remote machine. Either with guest credentials or with specified username/password.",
        name="smb_vuln_ms10_054")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_ms10_054(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-regsvc-dos.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects Microsoft Windows systems vulnerable to the remote code execution vulnerability known as MS08-067. This check is dangerous and it may crash systems.  On a fairly wide scan conducted by Brandon Enright, we determined that on average, a vulnerable system is more likely to crash than to survive the check. Out of 82 vulnerable systems, 52 crashed. Please consider this before running the script.  This check was previously part of smb-check-vulns.nse.",
        name="smb_vuln_ms08_067")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_ms08_067(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-ms08-067.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects Microsoft Windows systems with Dns Server RPC vulnerable to MS07-029.  MS07-029 targets the <code>R_DnssrvQuery()</code> and <code>R_DnssrvQuery2()</code> RPC method which isa part of DNS Server RPC interface that serves as a RPC service for configuring and getting information from the DNS Server service. DNS Server RPC service can be accessed using \"\dnsserver\" SMB named pipe. The vulnerability is triggered when a long string is send as the \"zone\" parameter which causes the buffer overflow which crashes the service.  This check was previously part of smb-check-vulns.",
        name="smb_vuln_ms07_029")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_ms07_029(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-ms07-029.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects Microsoft Windows systems with Ras RPC service vulnerable to MS06-025.",
        name="smb_vuln_ms06_025")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_ms06_025(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-ms06-025.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects Microsoft Windows systems vulnerable to denial of service (CVE-2009-3103). This script will crash the service if it is vulnerable.  The script performs a denial-of-service against the vulnerability disclosed in CVE-2009-3103. This works against Windows Vista and some versions of Windows 7, and causes a bluescreen if successful. This check was previously part of smb-check-vulns.",
        name="smb_vuln_cve2009_3103")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_cve2009_3103(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-cve2009-3103.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks if target machines are vulnerable to the arbitrary shared library load vulnerability CVE-2017-7494.",
        name="smb_vuln_cve_2017_7494")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_cve_2017_7494(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-cve2009-3103.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects Microsoft Windows systems infected by the Conficker worm. This check is dangerous and it may crash systems. This check was previously part of smb-check-vulns.",
        name="smb_vuln_conficker")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_vuln_conficker(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-vuln-conficker.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Pulls back information about the remote system from the registry. Getting all of the information requires an administrative account, although a user account will still get a lot of it.",
        name="smb_system_info")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_system_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-system-info.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to grab the server's statistics over SMB and MSRPC, which uses TCP ports 445 or 139.  An administrator account is required to pull these statistics on most versions of Windows, and Vista and above require UAC to be turned down.  Some of the numbers returned here don't feel right to me, but they're definitely the numbers that Windows returns. Take the values here with a grain of salt.  These statistics are found using a single call to a SRVSVC function, <code>NetServerGetStatistics</code>. This packet is parsed incorrectly by Wireshark, up to version 1.0.3 (and possibly higher).",
        name="smb_server_stats")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_server_stats(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-server-stats.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to print text on a shared printer by calling Print Spooler Service RPC functions.  In order to use the script, at least one printer needs to be shared over SMB. If no printer is specified, script tries to enumerate existing ones by calling LANMAN API which might not be always available. LANMAN is available by default on Windows XP, but not on Vista or Windows 7 for example. In that case, you need to specify printer share name manually using <code>printer</code> script argument. You can find out available shares by using smb-enum-shares script.  Later versions of Windows require valid credentials by default which you can specify trough smb library arguments <code>smbuser</code> and <code>smbpassword</code> or other options.",
        name="smb_print_text")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_print_text(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-psexec.nse --script-args=smbuser=<username>,smbpass=<password>[,config=<config>] -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Exhausts a remote SMB server's connection limit by by opening as many connections as we can.  Most implementations of SMB have a hard global limit of 11 connections for user accounts and 10 connections for anonymous. Once that limit is reached, further connections are denied. This script exploits that limit by taking up all the connections and holding them.  This works better with a valid user account, because Windows reserves one slot for valid users. So, no matter how many anonymous connections are taking up spaces, a single valid user can still log in.  This is *not* recommended as a general purpose script, because a) it is designed to harm the server and has no useful output, and b) it never ends (until timeout).",
        name="smb_flood")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_flood(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-flood.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate the users on a remote Windows system, with as much information as possible, through two different techniques (both over MSRPC, which uses port 445 or 139; see <code>smb.lua</code>).",
        name="smb_enum_users")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-users.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to list shares using the <code>srvsvc.NetShareEnumAll</code> MSRPC function and retrieve more information about them using <code>srvsvc.NetShareGetInfo</code>.",
        name="smb_enum_shares")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_shares(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-shares.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Enumerates the users logged into a system either locally or through an SMB share. The local users can be logged on either physically on the machine, or through a terminal services session. Connections to a SMB share are, for example, people connected to fileshares or making RPC calls.",
        name="smb_enum_sessions")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_sessions(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-sessions.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Retrieves the list of services running on a remote Windows system. Each service attribute contains service name, display name and service status of each service.  Note: Modern Windows systems requires a privileged domain account in order to list the services. ",
        name="smb_enum_services")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_services(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-services.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Pulls a list of processes from the remote server over SMB. This will determine all running processes, their process IDs, and their parent processes. It is done by querying the remote registry service, which is disabled by default on Vista; on all other Windows versions, it requires Administrator privileges.  Since this requires administrator privileges, it isn't especially useful for a penetration tester, since they can effectively do the same thing with metasploit or other tools. It does, however, provide for a quick way to get process lists for a bunch of systems at the same time.  WARNING: I have experienced crashes in <code>regsvc.exe</code> while making registry calls against a fully patched Windows 2000 system; I've fixed the issue that caused it, but there's no guarantee that it (or a similar vulnerability in the same code) won't show up again. Since the process automatically restarts, it doesn't negatively impact the system, besides showing a message box to the user.",
        name="smb_enum_processes")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_processes(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-processes.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Obtains a list of groups from the remote Windows system, as well as a list of the group's users. This works similarly to <code>enum.exe</code> with the <code>/G</code> switch.",
        name="smb_enum_groups")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_groups(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-users.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate domains on a system, along with their policies. This generally requires credentials, except against Windows 2000. In addition to the actual domain, the \"Builtin\" domain is generally displayed. Windows returns this in the list of domains, but its policies don't appear to be used anywhere.",
        name="smb_enum_domains")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_enum_domains(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-enum-domains.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to guess username/password combinations over SMB, storing discovered combinations for use in other scripts. Every attempt will be made to get a valid list of users and to verify each username before actually using them.",
        name="smb_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def smb_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script smb-brute.nse -p445  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Enumerates a SIP server's valid extensions (users).  The script works by sending REGISTER SIP requests to the server with the specified extension and checking for the response status code in order to know if an extension is valid. If a response status code is 401 or 407, it means that the extension is valid and requires authentication. If the response status code is 200, it means that the extension exists and doesn't require any authentication while a 403 response status code means that extension exists but access is forbidden. To skip false positives, the script begins by sending a REGISTER request for a random extension and checking for response status code.",
        name="sip_enum_users")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def sip_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=sip-enum-users -sU -p 5060 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Spoofs a call to a SIP phone and detects the action taken by the target (busy, declined, hung up, etc.)  This works by sending a fake sip invite request to the target phone and checking the responses. A response with status code 180 means that the phone is ringing. The script waits for the next responses until timeout is reached or a special response is received.  Special responses include:  Busy (486), Decline (603), Timeout (408) or Hang up (200).",
        name="sip_call_spoof")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def sip_call_spoof(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=sip-call-spoof -sU -p 5060 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against Session Initiation Protocol (SIP) accounts. This protocol is most commonly associated with VoIP sessions.",
        name="sip_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def sip_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 5060 {context['ip']} --script=sip-brute"
        return print_str

    @sk_function(
        description=
        "Checks if target machines are vulnerable to the Samba heap overflow vulnerability CVE-2012-1182.",
        name="samba_vuln_cve_2012_1182")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def samba_vuln_cve_2012_1182(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=samba-vuln-cve-2012-1182  -p 139 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate RTSP media URLS by testing for common paths on devices such as surveillance IP cameras.  The script attempts to discover valid RTSP URLs by sending a DESCRIBE request for each URL in the dictionary. It then parses the response, based on which it determines whether the URL is valid or not.",
        name="rtsp_url_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rtsp_url_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script rtsp-url-brute -p 554  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the rsync remote file syncing protocol.",
        name="rsync_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rsync_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 873 --script rsync-brute --script-args 'rsync-brute.module=www'  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the WinPcap Remote Capture Daemon (rpcap).",
        name="rpcap_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rpcap_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2002  {context['ip']}  --script rpcap-brute"
        return print_str

    @sk_function(
        description=
        "Tests whether Java rmiregistry allows class loading.  The default configuration of rmiregistry allows loading classes from remote URLs, which can lead to remote code execution. The vendor (Oracle/Sun) classifies this as a design feature. ",
        name="rmi_vuln_classloader")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rmi_vuln_classloader(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=rmi-vuln-classloader -p 1099 {context['ip']}"
        return print_str

    @sk_function(description="", name="rlogin_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rlogin_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 513 --script rlogin-brute  {context['ip']} "
        return print_str

    @sk_function(description="", name="rexec_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rexec_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 512 --script rexec-brute  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force passwords auditing against a Redis key-value store.",
        name="redis_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def redis_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 6379  {context['ip']}  --script redis-brute"
        return print_str

    @sk_function(
        description=
        "Checks if a machine is vulnerable to MS12-020 RDP vulnerability.  The Microsoft bulletin MS12-020 patches two vulnerabilities: CVE-2012-0152 which addresses a denial of service vulnerability inside Terminal Server, and CVE-2012-0002 which fixes a vulnerability in Remote Desktop Protocol.",
        name="rdp_vuln_ms12_020")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rdp_vuln_ms12_020(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=rdp-vuln-ms12-020 -p 3389 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to identify whether a listening QNX QCONN daemon allows unauthenticated users to execute arbitrary operating system commands.  QNX is a commercial Unix-like real-time operating system, aimed primarily at the embedded systems market. The QCONN daemon is a service provider that provides support, such as profiling system information, to remote IDE components. The QCONN daemon runs on port 8000 by default. ",
        name="qconn_exec")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(description="the port to scan", name="port")
    #split
    def qconn_exec(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script qconn-exec --script-args qconn-exec.timeout=60,qconn-exec.bytes=1024,qconn-exec.cmd=\"uname -a\" -p  {context['port']}  {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects if naive signing is enabled on a Puppet server. This enables attackers to create any Certificate Signing Request and have it signed, allowing them to impersonate as a puppet agent. This can leak the configuration of the agents as well as any other sensitive information found in the configuration files.  This script makes use of the Puppet HTTP API interface to sign the request.  This script has been Tested on versions 3.8.5, 4.10. ",
        name="puppet_naivesigning")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(description="the port to scan", name="port")
    #split
    def puppet_naivesigning(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script qconn-exec --script-args qconn-exec.timeout=60,qconn-exec.bytes=1024,qconn-exec.cmd=\"uname -a\" -p  {context['port']}  {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tries to log into a POP3 account by guessing usernames and passwords.",
        name="pop3_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(description="the port to scan", name="port")
    #split
    def pop3_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script qconn-exec --script-args qconn-exec.timeout=60,qconn-exec.bytes=1024,qconn-exec.cmd=\"uname -a\" -p  {context['port']}  {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Retrieves or sets the ready message on printers that support the Printer Job Language. This includes most PostScript printers that listen on port 9100. Without an argument, displays the current ready message. With the <code>pjl_ready_message</code> script argument, displays the old ready message and changes it to the message given.",
        name="pjl_ready_message")
    #split
    def pjl_ready_message(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=pjl-ready-message.nse"
        return print_str

    @sk_function(description="Performs password guessing against PostgreSQL.",
                 name="pgsql_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def pgsql_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 5432 --script pgsql-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the pcAnywhere remote access protocol.  Due to certain limitations of the protocol, bruteforcing is limited to single thread at a time. After a valid login pair is guessed the script waits some time until server becomes available again.",
        name="pcanywhere_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def pcanywhere_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=pcanywhere-brute {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Guesses Oracle instance/SID names against the TNS-listener.  If the <code>oraclesids</code> script argument is not used to specify an alternate file, the default <code>oracle-sids</code> file will be used. ",
        name="oracle_sid_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def oracle_sid_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=oracle-sid-brute --script-args=oraclesids=/path/to/sidfile -p 1521-1560  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate valid Oracle user names against unpatched Oracle 11g servers (this bug was fixed in Oracle's October 2009 Critical Patch Update).",
        name="oracle_enum_users")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def oracle_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script oracle-enum-users --script-args oracle-enum-users.sid=ORCL,userdb=orausers.txt -p 1521-1560  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Exploits the CVE-2012-3137 vulnerability, a weakness in Oracle's O5LOGIN authentication scheme.  The vulnerability exists in Oracle 11g R1/R2 and allows linking the session key to a password hash.  When initiating an authentication attempt as a valid user the server will respond with a session key and salt.  Once received the script will disconnect the connection thereby not recording the login attempt. The session key and salt can then be used to brute force the users password.",
        name="oracle_brute_stealth")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def oracle_brute_stealth(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script oracle-brute-stealth -p 1521 --script-args oracle-brute-stealth.sid=ORCL  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against Oracle servers.  Running it in default mode it performs an audit against a list of common Oracle usernames and passwords.",
        name="oracle_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def oracle_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL  {context['host']} "
        return print_str

    @sk_function(description="", name="openvas_otp_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def openvas_otp_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the OpenVAS manager using OMPv2.",
        name="omp2_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def omp2_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 9390 --script omp2-brute {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Obtains and prints an NTP server's monitor data.  Monitor data is a list of the most recently used (MRU) having NTP associations with the target.",
        name="ntp_monlist")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ntp_monlist(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -pU:123 -Pn -n --script=ntp-monlist {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Queries Nagios Remote Plugin Executor (NRPE) daemons to obtain information such as load averages, process counts, logged in user information, etc.  This script attempts to execute the stock list of commands that are enabled. User-supplied arguments are not supported.",
        name="nrpe_enum")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def nrpe_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nrpe-enum -p 5666  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against an Nping Echo service. ",
        name="nping_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def nping_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 9929 --script nping-brute {context['ip']}"
        return print_str

    @sk_function(
        description=
        "z/OS JES Network Job Entry (NJE) 'I record' password brute forcer.  After successfully negotiating an OPEN connection request, NJE requires sending, what IBM calls, an 'I record'. This initialization record may sometimes require a password. This script, provided with a valid OHOST/RHOST for the NJE connection, brute forces the password.  Most systems only have one password, it is recommended to use the <code>brute.firstonly</code> script argument.",
        name="nje_pass_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def nje_pass_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=nje-pass-brute --script-args=ohost='POTATO',rhost='CACTUS' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "z/OS JES Network Job Entry (NJE) target node name brute force.  NJE node communication is made up of an OHOST and an RHOST. Both fields must be present when conducting the handshake. This script attemtps to determine the target systems NJE node name.",
        name="nje_node_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def nje_node_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script=nje-node-brute {context['ip']}"
        return print_str

    @sk_function(description="", name="nexpose_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def nexpose_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nexpose-brute -p 3780  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the Netbus backdoor (\"remote administration\") service.",
        name="netbus_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def netbus_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 12345 --script netbus-brute {context['ip']}"
        return print_str

    @sk_function(description="", name="nessus_xmlrpc_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def nessus_xmlrpc_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 12345 --script netbus-brute {context['ip']}"
        return print_str

    @sk_function(description="", name="nessus_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def nessus_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nessus-brute -p 1241  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Displays protocol and block device information from NBD servers.  The Network Block Device protocol is used to publish block devices over TCP. This script connects to an NBD server and attempts to pull down a list of exported block devices and their details ",
        name="nbd_info")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def nbd_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nessus-brute -p 1241  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to bypass authentication in MySQL and MariaDB servers by exploiting CVE2012-2122. If its vulnerable, it will also attempt to dump the MySQL usernames and password hashes.",
        name="mysql_vuln_cve2012_2122")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def mysql_vuln_cve2012_2122(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nessus-brute -p 1241  {context['host']} "
        return print_str

    @sk_function(
        description="Attempts to show all variables on a MySQL server.",
        name="mysql_variables")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def mysql_variables(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nessus-brute -p 1241  {context['host']} "
        return print_str

    @sk_function(description="Attempts to list all users on a MySQL server.",
                 name="mysql_users")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def mysql_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script nessus-brute -p 1241  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs valid-user enumeration against MySQL server using a bug discovered and published by Kingcope (http://seclists.org/fulldisclosure/2012/Dec/9).  Server version 5.x are susceptible to an user enumeration attack due to different messages during login when using old authentication mechanism from versions 4.x and earlier.",
        name="mysql_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def mysql_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=mysql-enum {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks for MySQL servers with an empty password for <code>root</code> or <code>anonymous</code>.",
        name="mysql_empty_password")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def mysql_empty_password(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=mysql-enum {context['ip']}"
        return print_str

    @sk_function(
        description="Attempts to list all databases on a MySQL server.",
        name="mysql_databases")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def mysql_databases(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=mysql-enum {context['ip']}"
        return print_str

    @sk_function(description="Performs password guessing against MySQL.",
                 name="mysql_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def mysql_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=mysql-brute {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to run a command using the command shell of Microsoft SQL Server (ms-sql).",
        name="ms_sql_xp_cmdshell")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ms_sql_xp_cmdshell(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445 --script ms-sql-discover,ms-sql-empty-password,ms-sql-xp-cmdshell  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to authenticate to Microsoft SQL Servers using an empty password for the sysadmin (sa) account.",
        name="ms_sql_empty_password")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ms_sql_empty_password(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445 --script ms-sql-empty-password --script-args mssql.instance-all  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs password guessing against Microsoft SQL Server (ms-sql). Works best in conjunction with the <code>broadcast-ms-sql-discover</code> script.",
        name="ms_sql_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ms_sql_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 445 --script ms-sql-brute --script-args mssql.instance-all,userdb=customuser.txt,passdb=custompass.txt  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the MongoDB database.",
        name="mongodb_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def mongodb_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 27017  {context['ip']}  --script mongodb-brute"
        return print_str

    @sk_function(
        description=
        "Enumerates SCADA Modbus slave ids (sids) and collects their device information.  Modbus is one of the popular SCADA protocols. This script does Modbus device information disclosure. It tries to find legal sids (slave ids) of Modbus devices and to get additional information about the vendor and firmware. ",
        name="modbus_discover")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def modbus_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script modbus-discover.nse --script-args='modbus-discover.aggressive=true' -p 502  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Connects to an RPA Tech Mobile Mouse server, starts an application and sends a sequence of keys to it. Any application that the user has access to can be started and the key sequence is sent to the application after it has been started.  The Mobile Mouse server runs on OS X, Windows and Linux and enables remote control of the keyboard and mouse from an iOS device.  The script has only been tested against OS X and will detect the remote OS and abort unless the OS is detected as Mac.",
        name="mmouse_exec")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def mmouse_exec(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 51010  {context['host']}  --script mmouse-exec"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the RPA Tech Mobile Mouse servers.  The Mobile Mouse server runs on OS X, Windows and Linux and enables remote control of the keyboard and mouse from an iOS device. ",
        name="mmouse_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def mmouse_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script mmouse-brute -p 51010  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against Mikrotik RouterOS devices with the API RouterOS interface enabled. ",
        name="mikrotik_routeros_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def mikrotik_routeros_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p8728 --script mikrotik-routeros-brute {context['ip']}"
        return print_str

    @sk_function(description="", name="metasploit_xmlrpc_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def metasploit_xmlrpc_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script metasploit-xmlrpc-brute -p 55553  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force username and password auditing against Metasploit msgrpc interface.",
        name="metasploit_msgrpc_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def metasploit_msgrpc_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script metasploit-msgrpc-brute -p 55553  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Gathers info from the Metasploit rpc service.  It requires a valid login pair. After authentication it tries to determine Metasploit version and deduce the OS type.  Then it creates a new console and executes few commands to get additional info. ",
        name="metasploit_info")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def metasploit_info(self, context: SKContext) -> str:
        print_str = f"sudo nmap {context['ip']} --script=metasploit-info --script-args username=root,password=root"
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate Logical Units (LU) of TN3270E servers.  When connecting to a TN3270E server you are assigned a Logical Unit (LU) or you can tell the TN3270E server which LU you'd like to use. Typically TN3270E servers are configured to  give you an LU from a pool of LUs. They can also have LUs set to take you to a specific application. This script attempts to guess valid LUs that bypass the default LUs you are assigned. For example, if a TN3270E server sends you straight to TPX you could use this script to find LUs that take you to TSO, CICS, etc.",
        name="lu_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def lu_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script lu-enum -p 23 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to brute-force LDAP authentication. By default it uses the built-in username and password lists.",
        name="ldap_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    @sk_function_context_parameter(
        description=
        " If set, the script will use it as a base for the password guessing attempts. If both ldap.base and ldap.upnsuffix are unset the user list must either contain the distinguished name of each user or the server must support authentication using a simple user name. See the AD discussion in the description. DO NOT use ldap.upnsuffix in conjunction with ldap.base as attempts to login will fail. ",
        name="ldap_base")
    #split
    def ldap_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 389 --script ldap-brute --script-args ldap.base={context['ldap_base']}  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against Couchbase Membase servers.",
        name="membase_brute")
    #split
    def membase_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 11211 --script membase-brute"
        return print_str

    @sk_function(
        description=
        "Discovers valid usernames by brute force querying likely usernames against a Kerberos service.",
        name="krb5_enum_users")
    #split
    def krb5_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='test'"
        return print_str

    @sk_function(
        description=
        "Attempts to exploit java's remote debugging port. When remote debugging port is left open, it is possible to inject java bytecode and achieve remote code execution. This script allows injection of arbitrary class files.",
        name="jdwp_inject")
    #split
    def jdwp_inject(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='test'"
        return print_str

    @sk_function(
        description=
        "Attempts to exploit java's remote debugging port. When remote debugging port is left open, it is possible to inject java bytecode and achieve remote code execution.  This script abuses this to inject and execute a Java class file that executes the supplied shell command and returns its output.  The script injects the JDWPSystemInfo class from nselib/jdwp-class/ and executes its run() method which accepts a shell command as its argument.",
        name="jdwp_exec")
    #split
    def jdwp_exec(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='test'"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against iSCSI targets.",
        name="iscsi_brute")
    #split
    def iscsi_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='test'"
        return print_str

    @sk_function(
        description=
        "Checks if an IRC server is backdoored by running a time-based command (ping) and checking how long it takes to respond.",
        name="irc_unrealircd_backdoor")
    #split
    def irc_unrealircd_backdoor(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='test'"
        return print_str

    @sk_function(description="", name="irc_sasl_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def irc_sasl_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script irc-sasl-brute -p 6667  {context['ip']} "
        return print_str

    @sk_function(description="", name="irc_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def irc_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script irc-brute -p 6667  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Generates a flood of Router Advertisements (RA) with random source MAC addresses and IPv6 prefixes.",
        name="ipv6_ra_flood")
    #split
    def ipv6_ra_flood(self, context: SKContext) -> str:
        print_str = f"sudo nmap -6 --script ipv6-ra-flood.nse"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against IPMI RPC server.",
        name="ipmi_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ipmi_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU --script ipmi-brute -p 623  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Runs a query against IBM Informix Dynamic Server using the given authentication credentials (see also: informix-brute).",
        name="informix_query")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def informix_query(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 9088  {context['host']}  --script informix-query --script-args informix-query.username=informix,informix-query.password=informix"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against IBM Informix Dynamic Server.",
        name="informix_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def informix_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script informix-brute -p 9088  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tests for the presence of the LibreOffice Impress Remote server. Checks if a PIN is valid if provided and will bruteforce the PIN if requested.",
        name="impress_remote_discover")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def impress_remote_discover(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script informix-brute -p 9088  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against IMAP servers using either LOGIN, PLAIN, CRAM-MD5, DIGEST-MD5 or NTLM authentication.",
        name="imap_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def imap_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 143,993 --script imap-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to identify IEC 60870-5-104 ICS protocol. After probing with a TESTFR (test frame) message, a STARTDT (start data transfer) message is sent and general interrogation is used to gather the list of information object addresses stored.",
        name="iec_identify")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def iec_identify(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 143,993 --script imap-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the Asterisk IAX2 protocol.",
        name="iax2_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def iax2_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 4569  {context['ip']}  --script iax2-brute"
        return print_str

    @sk_function(
        description=
        "Enumerates usernames in Wordpress blog/CMS installations by exploiting an information disclosure vulnerability existing in versions 2.6, 3.1, 3.1.1, 3.1.3 and 3.2-beta2 and possibly others.",
        name="http_wordpress_users")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_wordpress_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-wordpress-users {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Enumerates themes and plugins of Wordpress installations. The script can also detect  outdated plugins by comparing version numbers with information pulled from api.wordpress.org.",
        name="http_wordpress_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_wordpress_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-wordpress-users {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tries to detect the presence of a web application firewall and its type and version.  This works by sending a number of requests and looking in the responses for known behavior and fingerprints such as Server header, cookies and headers values.",
        name="http_waf_fingerprint")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_waf_fingerprint(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-waf-fingerprint {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to determine whether a web server is protected by an IPS (Intrusion Prevention System), IDS (Intrusion Detection System) or WAF (Web Application Firewall) by probing the web server with malicious payloads and detecting changes in the response code and body.",
        name="http_waf_detect")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_waf_detect(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-waf-detect  {context['host']} "
        return print_str

    @sk_function(
        description=
        "A vulnerability has been discovered in WNR 1000 series that allows an attacker to retrieve administrator credentials with the router interface.",
        name="http_vuln_wnr1000_creds")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_wnr1000_creds(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-vuln-wnr1000-creds {context['ip']} -p80"
        return print_str

    @sk_function(
        description=
        "Detects the RomPager 4.07 Misfortune Cookie vulnerability by safely exploiting it.",
        name="http_vuln_misfortune_cookie")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_misfortune_cookie(self, context: SKContext) -> str:
        print_str = f"sudo nmap {context['ip']} -p 7547 --script=http-vuln-misfortune-cookie"
        return print_str

    @sk_function(
        description=
        "An SQL Injection vulnerability affecting Joomla! 3.7.x before 3.7.1 allows for unauthenticated users to execute arbitrary SQL commands.",
        name="http_vuln_cve2017_8917")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2017_8917(self, context: SKContext) -> str:
        print_str = f"sudo nmap {context['ip']} -p 7547 --script=http-vuln-misfortune-cookie"
        return print_str

    @sk_function(
        description=
        "This script attempts to detect a vulnerability, CVE-2015-1427, which  allows attackers  to leverage features of this API to gain unauthenticated remote code execution (RCE).",
        name="http_vuln_cve2015_1427")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2015_1427(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-vuln-cve2015-1427 --script-args command= 'ls' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Exploits a remote code injection vulnerability (CVE-2014-8877) in Wordpress CM Download Manager plugin. Versions <= 2.0.0 are known to be affected.",
        name="http_vuln_cve2014_8877")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        default_value="nil",
        description=" Command to execute. Default: nil ",
        name="http_vuln_cve2014_8877_cmd")
    @sk_function_context_parameter(
        default_value="/",
        description=" Wordpress root directory on the website. Default: / ",
        name="http_vuln_cve2014_8877_uri")
    #split
    def http_vuln_cve2014_8877(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2014-8877 --script-args http-vuln-cve2014-8877.cmd={context['http_vuln_cve2014_8877_cmd']},http-vuln-cve2014-8877.uri={context['http_vuln_cve2014_8877_uri']} {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Exploits CVE-2014-3704 also known as 'Drupageddon' in Drupal. Versions < 7.32 of Drupal core are known to be affected. Vulnerability allows remote attackers to conduct SQL injection attacks via an array containing crafted keys.",
        name="http_vuln_cve2014_3704")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        description=" Drupal root directory on the website. Default: / ",
        name="http_vuln_cve2014_3704_uri")
    @sk_function_context_parameter(
        default_value="nil",
        description=" Shell command to execute. Default: nil ",
        name="http_vuln_cve2014_3704_cmd")
    #split
    def http_vuln_cve2014_3704(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2014-3704 --script-args http-vuln-cve2014-3704.cmd={context['http_vuln_cve2014_3704_cmd']},http-vuln-cve2014-3704.uri={context['http_vuln_cve2014_3704_uri']} {context['ip']}"
        return print_str

    @sk_function(
        description=
        "The vulnerability is a local file inclusion that can retrieve any file from the server. Currently, we read /etc/passwd and /dev/null, and compare the lengths to determine vulnerability.",
        name="http_vuln_cve2013_7091")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2013_7091(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-vuln-cve2013-7091 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects PHP-CGI installations that are vulnerable to CVE-2012-1823, This critical vulnerability allows attackers to retrieve source code and execute code remotely. ",
        name="http_vuln_cve2012_1823")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2012_1823(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-vuln-cve2012-1823 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tests for the CVE-2011-3368 (Reverse Proxy Bypass) vulnerability in Apache HTTP server's reverse proxy mode.",
        name="http_vuln_cve2011_3368")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2011_3368(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2011-3368 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Executes a directory traversal attack against a ColdFusion server and tries to grab the password hash for the administrator user.",
        name="http_vuln_cve2010_2861")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_vuln_cve2010_2861(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2010-2861  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Exploits cve-2009-3960 also known as Adobe XML External Entity Injection. This vulnerability permits to read local files remotely and is present in BlazeDS 3.2 and earlier, LiveCycle 8.0.1, 8.2.1, and 9.0, LiveCycle Data Services 2.5.1, 2.6.1, and 3.0, Flex Data Services 2.0.1, and ColdFusion 7.0.2, 8.0, 8.0.1, and 9.0.",
        name="http_vuln_cve2009_3960")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        default_value="/",
        description=" Points to the root path. Defaults to \"/\" ",
        name="http_vuln_cve2009_3960_root")
    #split
    def http_vuln_cve2009_3960(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-vuln-cve2009-3960 --script-args http-http-vuln-cve2009-3960.root={context['http_vuln_cve2009_3960_root']} {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Exploits a file disclosure vulnerability in Webmin (CVE-2006-3392) Webmin before 1.290 and Usermin before 1.220 calls the simplify_path function before decoding HTML.",
        name="http_vuln_cve2006_3392")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2006_3392(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-vuln-cve2006-3392 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Searches for web virtual hostnames by making a large number of HEAD requests against http servers using common hostnames.",
        name="http_vhosts")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vhosts(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vhosts -p 80,8080,443 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate valid usernames on web servers running with the mod_userdir module or similar enabled.",
        name="http_userdir_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_userdir_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vhosts -p 80,8080,443 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Spiders a website and attempts to identify output escaping problems where content is reflected back to the user.",
        name="http_unsafe_output_escaping")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_unsafe_output_escaping(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-unsafe-output-escaping {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Posts specially crafted strings to every form it encounters and then searches through the website for those strings to determine whether the payloads were successful.",
        name="http_stored_xss")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_stored_xss(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-unsafe-output-escaping {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Spiders an HTTP server looking for URLs containing queries vulnerable to an SQL injection attack. It also extracts forms from found websites and tries to identify fields that are vulnerable.",
        name="http_sql_injection")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_sql_injection(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-unsafe-output-escaping {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tests a web server for vulnerability to the Slowloris DoS attack by launching a Slowloris attack.",
        name="http_slowloris")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_slowloris(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-slowloris --max-parallelism 400  {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Spiders a web server and displays its directory structure along with number and types of files in each folder. Note that files listed as having an 'Other' extension are ones that have no extension or that are a root document.",
        name="http_sitemap_generator")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_sitemap_generator(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-sitemap-generator -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to exploit the \"shellshock\" vulnerability (CVE-2014-6271 and CVE-2014-7169) in web applications.",
        name="http_shellshock")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_shellshock(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV -p- --script http-shellshock {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Crawls webservers in search of RFI (remote file inclusion) vulnerabilities. It tests every form field it finds and every parameter of a URL containing a query.",
        name="http_rfi_spider")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_rfi_spider(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-rfi-spider -p80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Uploads a local file to a remote web server using the HTTP PUT method. You must specify the filename and URL path with NSE arguments.",
        name="http_put")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_put(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80  {context['ip']}  --script http-put --script-args http-put.url='/uploads/rootme.php',http-put.file='/tmp/rootme.php'"
        return print_str

    @sk_function(
        description=
        "Performs brute force password guessing against HTTP proxy servers.",
        name="http_proxy_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_proxy_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-proxy-brute -p 8080  {context['host']} "
        return print_str

    @sk_function(
        description=
        "PHP files are not handling safely the variable $_SERVER[\"PHP_SELF\"] causing Reflected Cross Site Scripting vulnerabilities.",
        name="http_phpself_xss")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_phpself_xss(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-phpself-xss -p80 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks if a web server is vulnerable to directory traversal by attempting to retrieve <code>/etc/passwd</code> or <code>\boot.ini</code>.",
        name="http_passwd")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_passwd(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-passwd --script-args http-passwd.root=/test/ {context['ip']}"
        return print_str

    @sk_function(description=
                 "Spiders a website and attempts to identify open redirects.",
                 name="http_open_redirect")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_open_redirect(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-open-redirect {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Exploits a null-byte poisoning vulnerability in Litespeed Web Servers 4.0.x before 4.0.15 to retrieve the target script's source code by sending a HTTP request with a null byte followed by a .txt file extension (CVE-2010-2333).",
        name="http_litespeed_sourcecode_download")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_litespeed_sourcecode_download(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-litespeed-sourcecode-download --script-args http-litespeed-sourcecode-download.uri=/phpinfo.php  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks for a vulnerability in IIS 5.1/6.0 that allows arbitrary users to access secured WebDAV folders by searching for a password-protected folder and attempting to access it.",
        name="http_iis_webdav_vuln")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_iis_webdav_vuln(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-iis-webdav-vuln -p80,8080  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to brute force the 8.3 filenames (commonly known as short names) of files and directories in the root folder of vulnerable IIS servers.",
        name="http_iis_short_name_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_iis_short_name_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-iis-short-name-brute {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs a simple form fuzzing against forms found on websites. Tries strings and numbers of increasing length and attempts to determine if the fuzzing was successful.",
        name="http_form_fuzzer")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    @sk_function_context_parameter(
        description=
        " a table with the targets of fuzzing, for example {{path = /index.html, minlength = 40002}, {path = /foo.html, maxlength = 10000}}.",
        name="http_form_fuzzer_targets")
    #split
    def http_form_fuzzer(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-form-fuzzer --script-args 'http-form-fuzzer.targets={context['http_form_fuzzer_targets']}' -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against http form-based authentication.",
        name="http_form_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_form_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-form-brute -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Exploits insecure file upload forms in web applications using various techniques like changing the Content-type header or creating valid image files containing the payload in the comment.",
        name="http_fileupload_exploiter")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_fileupload_exploiter(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-form-brute -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "This script crawls through the website to find any rss or atom feeds.",
        name="http_feed")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_feed(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-form-brute -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Spiders a site's images looking for interesting exif data embedded in .jpg files. Displays the make and model of the camera, the date the photo was taken, and the embedded geotag information.",
        name="http_exif_spider")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_exif_spider(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-exif-spider -p80,443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "This script crawls through the website and returns any error pages.",
        name="http_errors")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_errors(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-exif-spider -p80,443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Enumerates directories used by popular web applications and servers.  This parses a fingerprint file that's similar in format to the Nikto Web application scanner.",
        name="http_enum")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-exif-spider -p80,443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Enumerates Drupal users by exploiting an information disclosure vulnerability in Views, Drupal's most popular module.  Requests to admin/views/ajax/autocomplete/user/STRING return all usernames that begin with STRING. The script works by iterating STRING over letters to extract all usernames.",
        name="http_drupal_enum_users")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        default_value="/",
        description=" base path. Defaults to \"/\" ",
        name="http_drupal_enum_users_root")
    #split
    def http_drupal_enum_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-drupal-enum-users --script-args http-drupal-enum-users.root={context['http_drupal_enum_users_root']} {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Enumerates the installed Drupal modules/themes by using a list of known modules and themes. ",
        name="http_drupal_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_drupal_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-drupal-enum-users --script-args http-drupal-enum-users.root='/path/' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate the hashed Domino Internet Passwords that are (by default) accessible by all authenticated users. This script can also download any Domino ID Files attached to the Person document.",
        name="http_domino_enum_passwords")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_domino_enum_passwords(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-domino-enum-passwords -p 80  {context['host']}  --script-args http-domino-enum-passwords.username='patrik karlsson',http-domino-enum-passwords.password=secret"
        return print_str

    @sk_function(
        description=
        "It looks for places where attacker-controlled information in the DOM may be used to affect JavaScript execution in certain ways.",
        name="http_dombased_xss")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_dombased_xss(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-domino-enum-passwords -p 80  {context['host']}  --script-args http-domino-enum-passwords.username='patrik karlsson',http-domino-enum-passwords.password=secret"
        return print_str

    @sk_function(
        description=
        "Tries to find out the technology behind the target website. The script checks for certain defaults that might not have been changed, like common headers or URLs or HTML content.",
        name="http_devframework")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_devframework(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-domino-enum-passwords -p 80  {context['host']}  --script-args http-domino-enum-passwords.username='patrik karlsson',http-domino-enum-passwords.password=secret"
        return print_str

    @sk_function(
        description=
        "Tests for access with default credentials used by a variety of web applications and devices.",
        name="http_default_accounts")
    #split
    def http_default_accounts(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-default-accounts host/ip"
        return print_str

    @sk_function(
        description=
        "This script detects Cross Site Request Forgeries (CSRF) vulnerabilities.",
        name="http_csrf")
    #split
    def http_csrf(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-default-accounts host/ip"
        return print_str

    @sk_function(
        description=
        "Checks for backups and swap files of common content management system and web server configuration files.",
        name="http_config_backup")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_config_backup(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-config-backup {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Measures the time a website takes to deliver a web page and returns the maximum, minimum and average time it took to fetch a page.",
        name="http_chrono")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_chrono(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-chrono  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against http basic, digest and ntlm authentication.",
        name="http_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-brute -p 80  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to retrieve the configuration settings from a Barracuda Networks Spam & Virus Firewall device using the directory traversal vulnerability.",
        name="http_barracuda_dir_traversal")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    @sk_function_context_parameter(description="the port to scan", name="port")
    #split
    def http_barracuda_dir_traversal(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-barracuda-dir-traversal --script-args http-max-cache-size=5000000 -p  {context['port']}   {context['host']} "
        return print_str

    @sk_function(
        description=
        "Runs a console command on the Lotus Domino Console using the given authentication credentials (see also: domcon-brute)",
        name="domcon_cmd")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    @sk_function_context_parameter(
        description=" The command to run on the remote server ",
        name="domcon_cmd_cmd")
    #split
    def domcon_cmd(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2050  {context['host']}  --script domcon-cmd --script-args domcon-cmd.cmd={context['domcon_cmd_cmd']}"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the Lotus Domino Console.",
        name="domcon_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def domcon_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script domcon-brute -p 2050  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Requests a zone transfer (AXFR) from a DNS server.  The script sends an AXFR query to a DNS server.",
        name="dns_zone_transfer")
    #split
    def dns_zone_transfer(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script dns-zone-transfer.nse"
        return print_str

    @sk_function(
        description=
        "Attempts to perform a dynamic DNS update without authentication.",
        name="dns_update")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def dns_update(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 53 --script=dns-update --script-args=dns-update.hostname=foo.example.com,dns-update.ip=192.0.2.1 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks a DNS server for the predictable-TXID DNS recursion vulnerability. Predictable TXID values can make a DNS server vulnerable to cache poisoning attacks (see CVE-2008-1447).",
        name="dns_random_txid")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def dns_random_txid(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 53 --script=dns-random-txid {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks a DNS server for the predictable-port recursion vulnerability. Predictable source ports can make a DNS server vulnerable to cache poisoning attacks (see CVE-2008-1447).",
        name="dns_random_srcport")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def dns_random_srcport(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 53 --script=dns-random-srcport {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tries to enumerate domain names from the DNS server that supports DNSSEC NSEC3 records.  The script queries for nonexistant domains until it exhausts all domain ranges keeping track of hashes.",
        name="dns_nsec3_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def dns_nsec3_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap  -sU -p 53 {context['ip']} --script=dns-nsec3-enum --script-args dns-nsec3-enum.domains=example.com"
        return print_str

    @sk_function(
        description=
        "Enumerates DNS names using the DNSSEC NSEC-walking technique.",
        name="dns_nsec_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def dns_nsec_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sSU -p 53 --script dns-nsec-enum --script-args dns-nsec-enum.domains=example.com {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs a quick reverse DNS lookup of an IPv6 network using a technique which analyzes DNS server response codes to dramatically reduce the number of queries needed to enumerate large networks.",
        name="dns_ip6_arpa_scan")
    #split
    def dns_ip6_arpa_scan(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script dns-ip6-arpa-scan --script-args='prefix=2001:0DB8::/48'"
        return print_str

    @sk_function(
        description="Launches a DNS fuzzing attack against DNS servers.",
        name="dns_fuzz")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def dns_fuzz(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU --script dns-fuzz --script-args timelimit=2h {context['ip']}"
        return print_str

    @sk_function(
        description="Performs DNS cache snooping against a DNS server.",
        name="dns_cache_snoop")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        description=
        " an array of domain to check in place of the default list. ",
        name="dns_cache_snoop_domains")
    #split
    def dns_cache_snoop(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 53 --script dns-cache-snoop.nse --script-args 'dns-cache-snoop.mode=timed,dns-cache-snoop.domains={context['dns_cache_snoop_domains']}' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate DNS hostnames by brute force guessing of common subdomains.",
        name="dns_brute")
    #split
    def dns_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script dns-brute --script-args dns-brute.domain=foo.com,dns-brute.threads=6,dns-brute.hostlist=./hostfile.txt,newtargets -sS -p 80"
        return print_str

    @sk_function(
        description=
        "Detects and exploits a remote code execution vulnerability in the distributed compiler daemon distcc. The vulnerability was disclosed in 2002, but is still present in modern implementation due to poor configuration of the service.",
        name="distcc_cve2004_2687")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def distcc_cve2004_2687(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 3632  {context['ip']}  --script distcc-exec --script-args=\"distcc-exec.cmd={context['domcon_cmd_cmd']}\""
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the DelugeRPC daemon.",
        name="deluge_rpc_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def deluge_rpc_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script deluge-rpc-brute -p 58846  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to guess the name of the CVS repositories hosted on the remote server. With knowledge of the correct repository name, usernames and passwords can be guessed.",
        name="cvs_brute_repository")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def cvs_brute_repository(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2401 --script cvs-brute-repository  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against CVS pserver authentication.",
        name="cvs_brute")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def cvs_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 2401 --script cvs-brute  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Attempts to guess valid credentials for the Citrix PN Web Agent XML Service. The XML service authenticates against the local Windows server or the Active Directory.  This script makes no attempt of preventing account lockout. If the password list contains more passwords than the lockout-threshold accounts will be locked.",
        name="citrix_brute_xml")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def citrix_brute_xml(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=citrix-brute-xml --script-args=userdb=<userdb>,passdb=<passdb>,ntdomain=<domain> -p 80,443,8080  {context['host']} "
        return print_str

    @sk_function(
        description=
        "CICS User ID enumeration script for the CESL/CESN Login screen.",
        name="cics_user_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def cics_user_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=cics-user-enum -p 23 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "CICS User ID brute forcing script for the CESL login screen.",
        name="cics_user_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def cics_user_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=cics-user-brute -p 23 {context['ip']}"
        return print_str

    @sk_function(
        description="CICS transaction ID enumerator for IBM mainframes.",
        name="cics_enum")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def cics_enum(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=cics-enum -p 23 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Performs brute force password auditing against the Cassandra database.",
        name="cassandra_brute")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def cassandra_brute(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 9160  {context['ip']}  --script=cassandra-brute"
        return print_str

    @sk_function(
        description=
        "Exploits ClamAV servers vulnerable to unauthenticated clamav comand execution.",
        name="clamav_exec")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def clamav_exec(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script clamav-exec {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Tests a web server for vulnerability to the Slowloris DoS attack without actually launching a DoS attack.",
        name="http_slowloris_check")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_slowloris_check(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-slowloris-check  {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Exploits a directory traversal vulnerability in phpMyAdmin 2.6.4-pl1 (and possibly other versions) to retrieve remote files on the web server.",
        name="http_phpmyadmin_dir_traversal")
    #split
    def http_phpmyadmin_dir_traversal(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p80 --script http-phpmyadmin-dir-traversal --script-args=\"dir='/pma/',file='../../../../../../../../etc/passwd',outfile='passwd.txt'\" <host/ip>"
        return print_str

    @sk_function(
        description=
        "Detects vulnerabilities and gathers information (such as version numbers and hardware support) from VxWorks Wind DeBug agents.",
        name="wdb_version")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def wdb_version(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU -p 17185 --script wdb-version {context['ip']}"
        return print_str

    @sk_function(
        description=
        "For each available CPE the script prints out known vulns (links to the correspondent info) and correspondent CVSS scores.",
        name="vulners")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def vulners(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script vulners [--script-args mincvss=<arg_val>] {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether a server is vulnerable to the F5 Ticketbleed bug (CVE-2016-9244).",
        name="tls_ticketbleed")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def tls_ticketbleed(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script tls-ticketbleed {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to download an unprotected configuration file containing plain-text user credentials in vulnerable Supermicro Onboard IPMI controllers.",
        name="supermicro_ipmi_conf")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def supermicro_ipmi_conf(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script tls-ticketbleed {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks whether SSLv3 CBC ciphers are allowed (POODLE) Run with -sV to use Nmap's service scan to detect SSL/TLS on non-standard ports. Otherwise, ssl-poodle will only run on ports that are commonly used for SSL.",
        name="ssl_poodle")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ssl_poodle(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --version-light --script ssl-poodle -p 443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Checks whether the SSL certificate used by a host has a fingerprint that matches an included database of problematic keys. The only databases currently checked are the LittleBlackBox 0.1 database of compromised keys from various devices.",
        name="ssl_known_key")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ssl_known_key(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ssl-known-key -p 443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects whether a server is vulnerable to the OpenSSL Heartbleed bug (CVE-2014-0160).",
        name="ssl_heartbleed")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ssl_heartbleed(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-heartbleed {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Weak ephemeral Diffie-Hellman parameter detection for SSL/TLS services.",
        name="ssl_dh_params")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ssl_dh_params(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script ssl-dh-params {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Reports any private (RFC1918) IPv4 addresses found in the various fields of an SSL service's certificate.",
        name="ssl_cert_intaddr")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ssl_cert_intaddr(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-cert-intaddr {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether a server is vulnerable to the SSL/TLS \"CCS Injection\" vulnerability (CVE-2014-0224).",
        name="ssl_ccs_injection")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def ssl_ccs_injection(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-ccs-injection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to detect missing patches in Windows systems by checking the uptime returned during the SMB2 protocol negotiation.",
        name="smb2_vuln_uptime")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def smb2_vuln_uptime(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-ccs-injection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to detect if a Microsoft SMBv1 server is vulnerable to a remote code  execution vulnerability (ms17-010, a.k.a. EternalBlue).",
        name="smb_vuln_ms17_010")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def smb_vuln_ms17_010(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-ccs-injection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks if the target machine is running the Double Pulsar SMB backdoor.",
        name="smb_double_pulsar_backdoor")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def smb_double_pulsar_backdoor(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script ssl-ccs-injection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects RSA keys vulnerable to Return Of Coppersmith Attack (ROCA) factorization.  SSH hostkeys and SSL/TLS certificates are checked. The checks require recent updates to the openssl NSE library.",
        name="rsa_vuln_roca")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def rsa_vuln_roca(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 22,443 --script rsa-vuln-roca {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks if a VNC server is vulnerable to the RealVNC authentication bypass (CVE-2006-2369).",
        name="realvnc_auth_bypass")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def realvnc_auth_bypass(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 22,443 --script rsa-vuln-roca {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks if a NetBus server is vulnerable to an authentication bypass vulnerability which allows full access without knowing the password.",
        name="netbus_auth_bypass")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def netbus_auth_bypass(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 12345 --script netbus-auth-bypass {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks an IRC server for channels that are commonly used by malicious botnets.",
        name="irc_botnet_channels")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def irc_botnet_channels(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 6667 --script=irc-botnet-channels {context['ip']}"
        return print_str

    @sk_function(
        description=
        "IPMI 2.0 Cipher Zero Authentication Bypass Scanner. This module identifies IPMI 2.0 compatible systems that are vulnerable to an authentication bypass vulnerability through the use of cipher zero.",
        name="ipmi_cipher_zero")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def ipmi_cipher_zero(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU --script ipmi-cipher-zero -p 623  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Detects if a system with Intel Active Management Technology is vulnerable to the INTEL-SA-00075 privilege escalation vulnerability (CVE2017-5689). ",
        name="http_vuln_cve2017_5689")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2017_5689(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 16992 --script http-vuln-cve2017-5689 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether the specified URL is vulnerable to the Apache Struts Remote Code Execution Vulnerability (CVE-2017-5638).",
        name="http_vuln_cve2017_5638")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(description="the port to scan", name="port")
    #split
    def http_vuln_cve2017_5638(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p  {context['port']}  --script http-vuln-cve2017-5638 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to detect a privilege escalation vulnerability in Wordpress 4.7.0 and 4.7.1 that allows unauthenticated users to inject content in posts.",
        name="http_vuln_cve2017_1001000")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2017_1001000(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2017-1001000 --script-args http-vuln-cve2017-1001000='uri' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks for a remote code execution vulnerability (MS15-034) in Microsoft Windows systems (CVE2015-2015-1635).",
        name="http_vuln_cve2015_1635")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2015_1635(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2017-1001000 --script-args http-vuln-cve2017-1001000='uri' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether the Cisco ASA appliance is vulnerable to the Cisco ASA SIP Denial of Service Vulnerability (CVE-2014-2129).",
        name="http_vuln_cve2014_2129")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2014_2129(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-vuln-cve2014-2129 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether the Cisco ASA appliance is vulnerable to the Cisco ASA SSL VPN Authentication Bypass Vulnerability (CVE-2014-2128).",
        name="http_vuln_cve2014_2128")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2014_2128(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-vuln-cve2014-2128 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether the Cisco ASA appliance is vulnerable to the Cisco ASA SSL VPN Privilege Escalation Vulnerability (CVE-2014-2127).",
        name="http_vuln_cve2014_2127")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2014_2127(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-vuln-cve2014-2127 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects whether the Cisco ASA appliance is vulnerable to the Cisco ASA ASDM Privilege Escalation Vulnerability (CVE-2014-2126).",
        name="http_vuln_cve2014_2126")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2014_2126(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-vuln-cve2014-2126 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects a URL redirection and reflected XSS vulnerability in Allegro RomPager Web server. The vulnerability has been assigned CVE-2013-6786.  The check is general enough (script tag injection via Referer header) that some other software may be vulnerable in the same way.",
        name="http_vuln_cve2013_6786")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2013_6786(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-vuln-cve2014-2126 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects Ruby on Rails servers vulnerable to object injection, remote command executions and denial of service attacks. (CVE-2013-0156)  All Ruby on Rails versions before 2.3.15, 3.0.x before 3.0.19, 3.1.x before 3.1.10, and 3.2.x before 3.2.11 are vulnerable.",
        name="http_vuln_cve2013_0156")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_vuln_cve2013_0156(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-vuln-cve2013-0156 {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects a denial of service vulnerability in the way the Apache web server handles requests for multiple overlapping/simple ranges of a page.",
        name="http_vuln_cve2011_3192")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_vuln_cve2011_3192(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vuln-cve2011-3192.nse [--script-args http-vuln-cve2011-3192.hostname=nmap.scanme.org] -pT:80,443  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Tests whether a JBoss target is vulnerable to jmx console authentication bypass (CVE-2010-0738).  It works by checking if the target paths require authentication or redirect to a login page that could be bypassed via a HEAD request.",
        name="http_vuln_cve2010_0738")
    @sk_function_context_parameter(description="target ip", name="ip")
    @sk_function_context_parameter(
        default_value="{\" / jmx - console / \"}",
        description=
        " Array of paths to check. Defaults to {\"/jmx-console/\"} . ",
        name="http_vuln_cve2010_0738_paths")
    #split
    def http_vuln_cve2010_0738(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script=http-vuln-cve2010-0738 --script-args 'http-vuln-cve2010-0738.paths={context['http_vuln_cve2010_0738_paths']}' {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks for a path-traversal vulnerability in VMWare ESX, ESXi, and Server (CVE-2009-3733).",
        name="http_vmware_path_vuln")
    @sk_function_context_parameter(description="target ip or host name",
                                   name="host")
    #split
    def http_vmware_path_vuln(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-vmware-path-vuln -p80,443,8222,8333  {context['host']} "
        return print_str

    @sk_function(
        description=
        "Sends an HTTP TRACE request and shows if the method TRACE is enabled. If debug is enabled, it returns the header fields that were modified in the response.",
        name="http_trace")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_trace(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-trace -d  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Attempts to bypass password protected resources (HTTP 401 status) by performing HTTP verb tampering. If an array of paths to check is not set, it will crawl the web server and perform the check against any password protected resource that it finds.",
        name="http_method_tamper")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_method_tamper(self, context: SKContext) -> str:
        print_str = f"sudo nmap --script http-trace -d  {context['ip']} "
        return print_str

    @sk_function(
        description=
        "Attempts to discover JSONP endpoints in web servers. JSONP endpoints can be used to bypass Same-origin Policy restrictions in web browsers.  The script searches for callback functions in the response to detect JSONP endpoints. It also tries to determine callback function through URL(callback function may be fully or partially controllable from URL) and also tries to bruteforce the most common callback variables through the URL.",
        name="http_jsonp_detection")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_jsonp_detection(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-jsonp-detection {context['ip']}"
        return print_str

    @sk_function(description="", name="http_internal_ip_disclosure")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_internal_ip_disclosure(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-jsonp-detection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Detects Huawei modems models HG530x, HG520x, HG510x (and possibly others...) vulnerable to a remote credential and information disclosure vulnerability.",
        name="http_huawei_hg5xx_vuln")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_huawei_hg5xx_vuln(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-jsonp-detection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks for a Git repository found in a website's document root /.git/<something>) and retrieves as much repo information as possible, including language/framework, remotes, last commit message, and repository description.",
        name="http_git")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_git(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 80 --script http-jsonp-detection {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks whether target machines are vulnerable to anonymous Frontpage login.  Older, default configurations of Frontpage extensions allow remote user to login anonymously which may lead to server compromise.",
        name="http_frontpage_login")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_frontpage_login(self, context: SKContext) -> str:
        print_str = f"sudo nmap {context['ip']} -p 80 --script=http-frontpage-login"
        return print_str

    @sk_function(
        description=
        "Detects a firmware backdoor on some D-Link routers by changing the User-Agent to a \"secret\" value. Using the \"secret\" User-Agent bypasses authentication and allows admin access to the router.",
        name="http_dlink_backdoor")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_dlink_backdoor(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-dlink-backdoor {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Checks the cross-domain policy file (/crossdomain.xml) and the client-acces-policy file (/clientaccesspolicy.xml) in web applications and lists the trusted domains.",
        name="http_cross_domain_policy")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_cross_domain_policy(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV --script http-dlink-backdoor {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Examines cookies set by HTTP services.  Reports any session cookies set without the httponly flag.  Reports any session cookies set over SSL without the secure flag.",
        name="http_cookie_flags")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_cookie_flags(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-cookie-flags {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to enumerate users in Avaya IP Office systems 7.x.  Avaya IP Office systems allow unauthenticated access to the URI '/system/user/scn_user_list' which returns a XML file containing user information such as display name, full name and extension number.  * Tested on Avaya IP Office 7.0(27).",
        name="http_avaya_ipoffice_users")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_avaya_ipoffice_users(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-cookie-flags {context['ip']}"
        return print_str

    @sk_function(
        description=
        "Attempts to exploit an authentication bypass vulnerability in Adobe Coldfusion servers to retrieve a valid administrator's session cookie.",
        name="http_adobe_coldfusion_apsa1301")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_adobe_coldfusion_apsa1301(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-cookie-flags {context['ip']}"
        return print_str

    @sk_function(description="", name="http_aspnet_debug")
    @sk_function_context_parameter(description="target ip", name="ip")
    #split
    def http_aspnet_debug(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p 443 --script http-cookie-flags {context['ip']}"
        return print_str

    @sk_function(description="对某个ip或网址进行默认地端口扫描，探测该目标所开启的服务",
                 name="default_scan")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def default_scan(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sV -sC {context['target']}"
        return print_str

    @sk_function(description="扫描某个ip或网址的全部TCP开放端口", name="tcp_scan")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def tcp_scan(self, context: SKContext) -> str:
        print_str = f"sudo nmap -p0-65535 {context['target']} -T5 "
        return print_str

    @sk_function(description="扫描某个ip或网址的全部UDP开放端口", name="udp_scan")
    @sk_function_context_parameter(description="Target ip or hostname",
                                   name="target")
    #split
    def udp_scan(self, context: SKContext) -> str:
        print_str = f"sudo nmap -sU {context['target']} "
        return print_str
