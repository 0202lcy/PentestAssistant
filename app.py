import re

from model import ChatModel, QwenChatModel, GPTChatModel
from agent import PlannerAgent, RefinerAgent, ParamCheckerAgent, PlanCheckerAgent, ExecutorAgent, AnalystAgent


class PentestAssistant:

    def __init__(self, chat_model: ChatModel):
        self.chat_model = chat_model
        self.max_repeat_time = 3

        self._init_bot()

    def _init_bot(self):

        # init agent
        self.planner_agent = PlannerAgent(chat_model=self.chat_model)
        self.refiner_agent = RefinerAgent(chat_model=self.chat_model)
        self.param_checker_agent = ParamCheckerAgent(chat_model=self.chat_model)
        self.plan_checker_agent = PlanCheckerAgent(chat_model=self.chat_model)
        self.executor_agent = ExecutorAgent(chat_model=self.chat_model)
        self.analyst_agent = AnalystAgent(chat_model=self.chat_model)

        # init status
        self.plan = ""
        self.current_subplan = ""
        self.last_result = ""
        self.user_query = ""
        self.step_count = 0
        self.previous_step = 0

    def _reset_status(self):
        self.plan = ""
        self.current_subplan = ""
        self.last_result = ""
        self.user_query = ""
        self.step_count = 0
        self.previous_step = 0

    def process(self, query: str) -> None:
        while True:
            self.user_query = query
            # close current task
            if self.last_result == "quit":
                self._reset_status()
                self._print_bot_message("🐞 机器人状态已初始化,请输入任务请求，退出机器人请输入'quit':")
                break

            # just open new task and generate plan list
            if len(self.last_result) == 0:
                self.plan = self.planner_agent.process(self.user_query)
                self._print_bot_message(f"📃 总任务列表:\n{self.plan}")
            else:
                # update plan list according last subplan result
                self.plan = self.refiner_agent.process([self.plan, self.last_result])
                self._print_bot_message(f"📃 总任务列表:\n{self.plan}")

            # judge task cycle number
            self.current_subplan = self._get_current_subplan(self.plan)
            current_step = self._extract_step(self.current_subplan)
            if current_step is None:
                self._print_bot_message(f"🐞 无法解析任务标号：{self.current_subplan}")
                break
            if current_step == self.previous_step:
                self.step_count += 1
            else:
                self.step_count = 1  # 遇到不同的标号，重置计数
                self.previous_step = current_step  # 更新上一次的标号
            if self.step_count >= self.max_repeat_time:
                self.last_result = "该步骤已失败且无法完成，请生成新任务或跳到下一步骤"
                continue

            self._print_bot_message(f"✨ 当前任务:\n{self.current_subplan}")

            plan_pattern = self.plan_checker_agent.process(self.current_subplan)
            if plan_pattern == "auto":
                self.last_result = self.executor_agent.process(self.current_subplan)
                self._print_bot_message(f"🔧 工具执行结果:\n{self.last_result}")
            elif plan_pattern == "anal":
                self.last_result = self.analyst_agent.process([self.current_subplan, self.last_result])
                self._print_bot_message(f"🔧 任务分析结果：\n{self.last_result}")
            else:
                self._print_bot_message(f"🌈 请输入目前步骤的结果(输入'quit'退出):")
                self.last_result = input()

        return

    def _extract_step(self, output_string):
        # 使用正则表达式提取标号（假设标号为数字后跟一个点号，如 "2."）
        match = re.match(r"\s*(\d+(\.\d+)?)[\.\s]", output_string)
        if match:
            return match.group(1)  # 返回匹配的标号部分
        return None

    def _get_current_subplan(self, plan: str):
        """ 获取当前的子任务 """
        insts = plan.split('\n')
        instNow = ''
        for self.current_subplan in insts:
            if '[当前步骤]' in self.current_subplan:
                instNow = self.current_subplan
                break
        instNow.replace("当前步骤", "")
        return instNow

    def _remove_ansi_escape_sequences(self, text):
        ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
        return ansi_escape.sub('', text)

    def _extract_first_level_title(task_label: str) -> int:
        # 以"."分割任务标号并取第一个部分，将其转化为int类型
        first_level_title = int(task_label.split('.')[0])
        return first_level_title

    def _extract_plan(self, output):
        if "[plan]" in output and "[plan end]" in output:
            # 存在 [plan] 和 [plan end] 时，提取中间部分
            parts = output.split("[plan]")[1].split("[plan end]")[0].strip()
            return parts
        elif "[plan end]" in output:
            # 只有 [plan end] 时，从开头提取到 [plan end]
            parts = output.split("[plan end]")[0].strip()
            return parts
        else:
            # 如果没有 [plan] 或 [plan end]，直接返回原始内容
            return output.strip()

    def _print_bot_message(self, msg: str):
        print(f"\033[31m{msg}\033[0m")


if __name__ == "__main__":
    chat_model = QwenChatModel()
    # chat_model = GPTChatModel()
    pa = PentestAssistant(chat_model=chat_model)
    query = input("请输入任务请求，退出机器人请输入'quit':\n")
    while True:
        if query == "quit":
            break
        pa.process(query)
        query = input()
