"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
import subprocess
from typing import Tuple, Optional

from log import logger
from retrieval import Retrieval
from plugin import plugin
from planner.base import Plan, Planner

PROMPT = """You are a planner for the Semantic Kernel.
Your job is to create a properly formatted JSON plan step by step, to satisfy the goal given.
Create a list of subtasks based off the [GOAL] provided.
Each subtask must be from within the [AVAILABLE FUNCTIONS] list. Do not use any functions that are not in the list.
Base your decisions on which function to use from the description and the name of the function, only one function can be given.
Sometimes, a function may take arguments. Provide them if necessary.
The plan should be as short as possible.
For example:

[AVAILABLE FUNCTIONS]
Tplmap.tplmap_shell
description: Run shell on the target , only can be used when the former tplmap scan result of this capability is available
args:
- target: target url address

Tplmap.tplmap_scan_default
description: Automatic Server-Side Template Injection Detection using default option
args:
- target: target url address

Tplmap.tplmap_file_upload
description: Upload files to the server ,only can be used when the former tplmap scan result of this capability is available.
args:
- target: target url address
- localpath: the path of the upload file
- serverpath: The path where the uploaded file is saved on the server"


[GOAL]
"Please help me scan the sstl-related vulnerability information at the wwww.baidu.com address"

[OUTPUT]
{{
    "function": "Tplmap.tplmap_scan_default",
    "args": {{
        "target": "192.167.0.2"
    }}
}}

[AVAILABLE FUNCTIONS]
{available_functions}

[GOAL]
{goal}

[OUTPUT]
"""


class TplmapPlanner(Planner):
    """
    Basic JSON-based planner for the Semantic Kernel.
    """

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)
        self.skill = plugin.read_skill(self.skill_name)

    def _create_available_functions_string(self, goal: str) -> str:
        """
        Given an instance of the Kernel, create the [AVAILABLE FUNCTIONS]
        string for the prompt.
        """
        functions = self.skill.functions
        functions_description = []
        for function in functions:
            functions_description.append(function.description)

        # Create the [AVAILABLE FUNCTIONS] section of the prompt
        available_functions_string = ""
        for function in functions:
            available_functions_string += f"{self.skill_name}.{function.name}\n"
            available_functions_string += f"description: {function.description}\n"
            available_functions_string += "args:\n"

            # Add the parameters for each function
            for arg in function.parameters:
                if not arg.description:
                    param_description = ""
                else:
                    param_description = arg.description
                available_functions_string += ("- " + arg.name + ": " + param_description + "\n")
            available_functions_string += "\n"

        logger.info(": available_functions - {available_functions_string}".format(available_functions_string=available_functions_string))
        return available_functions_string

    def _check_generated_plan(
        self,
        generated_plan: str,
    ) -> Tuple[int, Optional[dict]]:
        """
        check if generate_plan have json format plan, and set default
        value for args
        """

        json_regex = r"\{(?:[^{}]|(?R))*\}"
        generated_plan_string = regex.findall(json_regex, generated_plan)[0]
        generated_plan_json = json.loads(generated_plan_string)
        # check json format, name, and param
        # try:
        #     generated_plan_json = json.loads(generated_plan_string)
        #     skill_name, function_name = generated_plan_json["function"].split(".")
        #     if not self.kernel.skills.has_native_function(skill_name, function_name):
        #         logger.error(": Check Generated Plan: plan does not have correct function name - {plan}".format(plan=repr(generated_plan)))
        #         return ReturnCodeEnum.CREATE_FUNCTION_NAME_FAIL, generated_plan_json

        #     for arg in self.kernel.skills.get_native_function(skill_name, function_name).parameters:
        #         if arg.name not in generated_plan_json["args"]:
        #             logger.error(": Check Generated Plan: plan does not have correct function params - {plan}".format(plan=repr(generated_plan)))
        #             return ReturnCodeEnum.CREATE_FUNCTION_PARAM_FAIL, generated_plan_json

        #         # add default value
        #         if arg.default_value != "" and arg.name not in generated_plan_json["args"]:
        #             generated_plan_json["args"][arg.name] = arg.default_value
        # except:
        #     logger.error(": Check Generated Plan: plan does not have correct format - {plan}".format(plan=repr(generated_plan)))
        #     return ReturnCodeEnum.CREATE_FUNCTION_FORMAT_FAIL, generated_plan_json

        return generated_plan_json

    def create_plan(
        self,
        goal: str,
    ) -> Tuple[int, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """

        # Create the semantic function for the planner with the given prompt
        available_functions_string = self._create_available_functions_string(goal)

        # Create the prompt for the planner
        prompt = PROMPT.format(available_functions=available_functions_string, goal=goal)
        generated_plan = self.chat_model.chat(prompt)
        generated_plan_json = self._check_generated_plan(generated_plan)

        return 0, Plan(prompt=PROMPT, goal=goal, generated_plan=generated_plan_json)

    def exec_tplmap(self, cmd: str) -> str:
        process = subprocess.run(cmd.split(), capture_output=True)

        if process.returncode != 0:
            logger.warn(f": tplmap call error - {repr(cmd)} - {repr(process.stderr.decode())}")

        return process.stdout.decode()

    def execute_plan(self, plan: Plan) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": Tplmap Planner Plan -: {plan}".format(plan=repr(plan.generated_plan)))
        generated_plan_json = plan.generated_plan

        # get function from generated_plan_json
        _, function_name = generated_plan_json["function"].split(".")
        function = self.skill.get_function(function_name)
        # if function is None

        # parse params from generated_plan_json and exec function
        exec_str = function.exec_str
        for arg_name, arg_value in generated_plan_json["args"].items():
            exec_str = exec_str.replace(f"{{{{{str(arg_name)}}}}}", str(arg_value))

        result = self.exec_tplmap(exec_str)

        return result
