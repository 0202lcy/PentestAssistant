"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
import subprocess
from typing import Tuple, Optional

from log import logger
from retrieval import Retrieval
from plugin import plugin
from planner.base import Plan, Planner



class NmapPlanner(Planner):
    """A planner for nmap tool api retrieval"""

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)
        self.skill = plugin.read_skill(self.skill_name)

    def _create_available_functions(self, goal: str) -> str:
        """
        generates a filtered list of callable tools (functions) based on their relevance to a given goal.
        """
        functions = self.skill.functions
        functions_description = []
        for function in functions:
            functions_description.append(function.description)

        topk_descriptions = self.reranker.compute_topk(goal, functions_description, top_k=10)

        tools = []
        for function in functions:
            if function.description not in topk_descriptions:
                continue

            tool = {
                "type": "function",
                "function": {
                    "name": self.skill_name + "." + function.name,
                    "description": function.description,
                    "parameters": {
                        "type": "object",
                        "properties": {
                            arg.name: {
                                "type": "string",
                                "description": arg.description
                            }
                            for arg in function.parameters
                        }
                    },
                    "required": []
                }
            }
            tools.append(tool)

        logger.info(": available_functions - {tools}".format(tools=tools))
        return tools


    def create_plan(
        self,
        goal: str,
    ) -> Tuple[int, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """

        # Create the semantic function for the planner with the given prompt
        tools = self._create_available_functions(goal)

        generated_plan = self.chat_model.function_call(goal, tools)
        logger.info(f"generated_plan - {generated_plan}")

        return 0, Plan(prompt=goal, goal=goal, generated_plan=generated_plan)

    def _exec_nmap(self, cmd: str) -> str:
        process = subprocess.run(cmd.split(), capture_output=True)

        if process.returncode != 0:
            logger.warn(f": nmap call error - {repr(cmd)} - {repr(process.stderr.decode())}")

        return process.stdout.decode("utf-8", "ignore")

    def execute_plan(self, plan: Plan) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": Nmap Planner Plan -: {plan}".format(plan=repr(plan.generated_plan)))
        generated_plan_json = plan.generated_plan

        # get function from generated_plan_json
        _, function_name = generated_plan_json["name"].split(".")
        function = self.skill.get_function(function_name)
        # if function is None

        # parse params from generated_plan_json and exec function
        exec_str = function.exec_str
        if isinstance(generated_plan_json["arguments"], str):
            generated_plan_json["arguments"] = json.loads(generated_plan_json["arguments"])

        for arg_name, arg_value in generated_plan_json["arguments"].items():
            exec_str = exec_str.replace(f"{{{{{str(arg_name)}}}}}", str(arg_value))

        result = self._exec_nmap(exec_str)

        return result
