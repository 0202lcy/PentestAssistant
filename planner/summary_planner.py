"""A basic JSON-based planner for the Python Semantic Kernel"""
import json

from semantic_kernel.kernel import Kernel


from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """\
你是一个缩句机器人，擅长把一段较长的建议缩减为保留原意的较短的建议。需要被缩短的建议在“[建议]”标识下方，请你在[结果]标识下方将缩句结果输出出来。
下面是一个例子：
[建议]
假设所有输入均是恶意的。使用“接受已知良好”输入验证策略，即使用严格符合规范的可接受输入列表。拒绝任何不严格符合规范的输入，或将其转换为符合规范的内容。\n在执行输入验证时，考虑所有可能相关的属性，包括长度、输入类型、可接受值的完整范围、缺少或多余的输入、语法、相关字段之间的一致性以及符合业务规则。作为业务规则逻辑的示例，“boat”在语法上是有效的，因为它只包含字母数字字符，但如果期望输入只包含像“red”或“blue”这样的颜色，则它是无效的。\n不要仅仅依赖于查找恶意或格式错误的输入。这很可能会漏掉至少一个不受欢迎的输入，特别是如果代码的环境发生变化。这将给攻击者足够的空间来绕过预期的验证。然而，拒绝列表可以用于检测潜在攻击或确定哪些输入是如此格式错误以至于应该被直接拒绝的。\n在构建SQL查询字符串时，使用严格的允许列表，根据请求中参数的预期值来限制字符集。这间接限制了攻击范围，但这种技术不如适当的输出编码和转义重要。\n请注意，适当的输出编码、转义和引用是防止SQL注入最有效的解决方案，尽管输入验证可能提供一定的深度防御。这是因为它有效地限制了输出中可能出现的内容。输入验证并不总能防止SQL注入，特别是如果您需要支持可能包含任意字符的自由文本字段。例如，名字\"O'Reilly\"可能会通过验证步骤，因为它是英语中常见的姓氏。但是，它不能直接插入数据库，因为它包含\"'\"的撇号字符，需要进行转义或其他处理。在这种情况下，去除撇号可能会减少SQL注入的风险，但会产生错误行为，因为将记录错误的名称。\n在可行的情况下，最安全的做法可能是完全禁止使用元字符，而不是转义它们。这将提供一定的深度防御。在数据输入到数据库后，后续处理过程可能忽略在使用之前转义元字符，而您可能无法控制这些处理过程。
[输出]
输入验证策略：采用“接受已知良好”的策略，拒绝或转换不符合规范的输入，全面考虑长度、类型、范围、语法、一致性和业务规则。
避免依赖单一检测：不要仅依赖检测恶意或错误输入，使用允许列表和拒绝列表来增强安全性。
SQL查询构建：使用允许列表限制SQL查询中的字符集，但务必重视输出编码、转义和引用，以有效防止SQL注入。
禁用元字符：在可能的情况下，完全禁用元字符而非仅转义，提供更深层的防御。

例子完毕，下面开始真实场景应用，输出完结果后结束输出并用[结束]标识。
[建议]
{{$input}}
[结果]
"""


class SummaryPlanner(Planner):

    def __init__(self,
                 kernel: Kernel,
                 skill_name: str,
                 reranker: Retrieval = None) -> None:
        super().__init__(kernel, skill_name, reranker)
        self.planner = kernel.create_semantic_function(PROMPT,
                                                       max_tokens=500,
                                                       temperature=0.8)

    async def _process_vuln(self, vulns):
        res = ""
        for id in range(len(vulns)):
            cwe = vulns[id]["cwe"]
            name = vulns[id]["name"]
            des = vulns[id]["description"]
            res += f"漏洞{id+1}. cwe: {cwe} {name}\n"
            res += f"该漏洞表现为{des}\n"
            miti = vulns[id]["mitigation"]
            if len(miti) == 0:
                res += "暂无修复意见\n"
            else:
                res += "针对该漏洞的修复意见如下:\n"

            for i in range(len(miti)):
                su = miti[i]["suggestion"]
                if len(su) >= 230:
                    # context = ContextVariables()
                    # context["input"] = su
                    # response = await self.planner.invoke_async(variables=context)
                    # su = response.result.split("[end of text]")[0].split("[结果]")[2].split("[结束]")[0]
                    pass
                res += f"\t{i}: {su}\n"

        return res

    async def create_plan_async(self, goal: str) -> Plan | None:
        logger.info(f": Summary Planner Goal - {repr(goal)}")

        report = json.loads(goal)
        res = ""
        urls_num = len(report["urls"])
        vulns_num = len(report["vulns"])
        res += f"扫描共探测到{urls_num}个url,共检测到{vulns_num}个漏洞.其中:\n"
        high_vulns = []
        medium_vulns = []
        low_vulns = []
        for vuln in report["vulns"]:
            if vuln["level"] == "high":
                high_vulns.append(vuln)
            elif vuln["level"] == "medium":
                medium_vulns.append(vuln)
            else:
                low_vulns.append(vuln)
        high_nums = len(high_vulns)
        medium_num = len(medium_vulns)
        low_num = len(low_vulns)
        res += f"高危漏洞{high_nums}个,分别为:\n"
        res += await self._process_vuln(high_vulns)
        res += f"中危漏洞{medium_num}个,分别为:\n"
        res += await self._process_vuln(medium_vulns)
        res += f"低危漏洞{low_num}个,分别为:\n"
        res += await self._process_vuln(low_vulns)
        res += "详细修复意见参见扫描报告"

        logger.info(f": Summary Planner Result - {repr(res)}")

        return Plan(prompt=PROMPT, goal=goal, generated_plan=res)

    async def execute_plan_async(self, plan: Plan) -> str:
        return plan.generated_plan
