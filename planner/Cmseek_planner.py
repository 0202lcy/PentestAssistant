"""A basic JSON-based planner for the Python Semantic Kernel"""
import json
import regex
import subprocess
from typing import Tuple, Optional

from log import logger
from retrieval import Retrieval
from plugin import plugin
from planner.base import Plan, Planner



class CmseekPlanner(Planner):
    """
    Basic JSON-based planner for the Semantic Kernel.
    """

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)
        self.skill = plugin.read_skill(self.skill_name)

    def _create_available_functions(self, goal: str) -> str:
        """
        generates a filtered list of callable tools (functions) based on their relevance to a given goal.
        """
        functions = self.skill.functions
        functions_description = []
        for function in functions:
            functions_description.append(function.description)

        # Create the [AVAILABLE FUNCTIONS] section of the prompt
        tools = []
        for function in functions:

            tool = {
                "type": "function",
                "function": {
                    "name": self.skill_name + "." + function.name,
                    "description": function.description,
                    "parameters": {
                        "type": "object",
                        "properties": {
                            arg.name: {
                                "type": "string",
                                "description": arg.description
                            }
                            for arg in function.parameters
                        }
                    },
                    "required": []
                }
            }
            tools.append(tool)

        logger.info(": available_functions - {tools}".format(tools=tools))
        return tools


    def create_plan(
        self,
        goal: str,
    ) -> Tuple[int, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the kernel.
        """
        logger.info(f": Cmseek Planner Goal - {goal}")

        # Create the semantic function for the planner with the given prompt
        tools = self._create_available_functions(goal)

        generated_plan = self.chat_model.function_call(goal, tools)
        logger.info(f"generated_plan - {generated_plan}")

        return 0, Plan(prompt=goal, goal=goal, generated_plan=generated_plan)

    def exec_cmseek(self, cmd: str) -> str:
        process = subprocess.run(cmd.split(), capture_output=True)

        if process.returncode != 0:
            logger.warn(f": Cmseek call error - {repr(cmd)} - {repr(process.stderr.decode())}")

        return process.stdout.decode()

    def execute_plan(self, plan: Plan) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": Cmseek Planner Plan -: {plan}".format(plan=repr(plan.generated_plan)))
        generated_plan_json = plan.generated_plan

        # get function from generated_plan_json
        _, function_name = generated_plan_json["name"].split(".")
        function = self.skill.get_function(function_name)
        # if function is None

        # parse params from generated_plan_json and exec function
        exec_str = function.exec_str
        if isinstance(generated_plan_json["arguments"], str):
            generated_plan_json["arguments"] = json.loads(generated_plan_json["arguments"])
        for arg_name, arg_value in generated_plan_json["arguments"].items():
            exec_str = exec_str.replace(f"{{{{{str(arg_name)}}}}}", str(arg_value))

        result = self.exec_cmseek(exec_str)

        return result
