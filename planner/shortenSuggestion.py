"""A basic str-based planner for the Python Semantic Kernel"""

from log import logger
from retrieval import Retrieval
from planner.base import Plan, Planner

PROMPT = """
You are a sentence-compression robot skilled in shortening long advice into concise suggestions while preserving the original meaning. The advice to be shortened is under the "[Advice]" section. Please output the compressed result under the "[Result]" section.

Below is an example:

[Advice]  
Assume all inputs are malicious. Use an "accept known good" input validation strategy, which employs a strictly defined list of acceptable inputs. Reject any input that does not strictly conform to specifications or transform it into a compliant form. When performing input validation, consider all potentially relevant attributes, including length, input type, full range of acceptable values, missing or extra inputs, syntax, consistency between related fields, and compliance with business rules. For example, as a business rule, "boat" is syntactically valid because it contains only alphanumeric characters. However, it is invalid if the input is expected to include only colors such as "red" or "blue."  
Do not rely solely on identifying malicious or malformed inputs. This approach is likely to miss at least one unwanted input, especially if the environment of the code changes, leaving room for attackers to bypass expected validations. However, deny-lists can help detect potential attacks or identify inputs so malformed they should be outright rejected.  
When constructing SQL query strings, use a strict allow-list to limit the character set based on the expected values of parameters in the request. This indirectly reduces the attack surface, but this technique is less critical than proper output encoding and escaping.  
Proper output encoding, escaping, and quoting are the most effective solutions for preventing SQL injection, even though input validation may provide some defense-in-depth. This is because it effectively limits the content that may appear in the output. Input validation does not always prevent SQL injection, particularly if free-text fields that may contain arbitrary characters are supported. For example, the name "O'Reilly" might pass validation because it is a common surname in English. However, it cannot be directly inserted into a database because it contains the apostrophe character "'", which needs to be escaped or otherwise handled. In such cases, removing apostrophes might reduce the risk of SQL injection but could cause incorrect behavior by recording incorrect names.  
Where feasible, the safest approach may be to completely disallow the use of meta-characters rather than escaping them. This provides a level of defense-in-depth. Once data is input into the database, subsequent processing steps might ignore escaping before use, and you may not control those processes.  

[Result]  
Input validation strategy: Use an "accept known good" strategy to reject or transform non-compliant inputs while considering length, type, range, syntax, consistency, and business rules.  
Avoid sole reliance on detection: Don't rely solely on detecting malicious or malformed inputs; enhance security with allow- and deny-lists.  
SQL query construction: Use allow-lists to restrict SQL query character sets, but prioritize output encoding, escaping, and quoting to prevent SQL injection effectively.  
Disable meta-characters: Where feasible, completely disable meta-characters instead of escaping them to provide deeper defense.  

End of example. Real application begins below. Conclude the output with "[End]".  

[Advice]  
{input}  
[Result]  

"""


class ShortenSuggestion(Planner):

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)

    def create_plan(self, goal: str) -> Plan | None:
        logger.info(f": Capability check query input - {repr(goal)}")

        # Create the context for the planner
        prompt = PROMPT.format(input=goal)
        response = self.chat_model.chat(prompt)

        return Plan(prompt=PROMPT, goal=goal, generated_plan=response)

    def execute_plan(self, plan: Plan) -> str:
        return plan.generated_plan
