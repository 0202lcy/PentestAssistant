from typing import Optional, Union
from flask import Flask, request
from flask_cors import CORS
from pydantic import BaseModel

from wenxinAgent import planner
from wenxinAgent import refiner
from wenxinAgent import checker
from wenxinAgent import analyst
from wenxinAgent import param_check
import requests

import sys
import os

import re
import json

# 获取当前文件的路径
current_file_path = os.path.dirname(os.path.abspath(__file__))
print(current_file_path)
# 获取兄弟目录子目录的路径
target_module_path = os.path.join(current_file_path, '.', 'robotend', 'bot')
print(target_module_path)
# 将该路径添加到sys.path
sys.path.append(target_module_path)

# 现在可以导入目标模块
import state
from state import bot_state

p = planner()
r = refiner()
c = checker()
a = analyst()
pc = param_check()

app = Flask(__name__)
CORS(app)


class Response(BaseModel):
    code: int
    msg: str
    data: Optional[Union[str, dict]]


# 初始化变量
previous_step = None  # 上一轮的任务标号
step_count = 0  # 相同标号的计数
max_repeats = 3  # 连续相同标号的最大允许次数


# 提取标号的函数
def extract_step(output_string):
    match = re.match(r"\s*(\d+(\.\d+)?)[\.\s]", output_string)
    if match:
        return match.group(1)  # 返回匹配的标号部分
    return None


def getInst(plan: str):
    insts = plan.split('\n')
    instNow = ''
    for inst in insts:
        if '[当前步骤]' in inst:
            instNow = inst
            break
    instNow.replace("当前步骤", "")
    return instNow


# 表示当前有无计划正在执行
flag = False


@app.route("/chat", methods=["POST"])
async def chat() -> dict:
    target = request.get_json()["question"]
    result = sendmessage(target)
    return Response(code=int(0), msg=result, data=None).dict()


# @app.route("/status", methods=["GET"])
# async def read_status() -> dict:
#     return Response(code=0, msg="成功", data="成功").dict()
@app.route("/status", methods=["GET"])
async def read_status() -> dict:
    return Response(code=0, msg="成功", data=bot_state.get_state()).dict()


init = False
plannow = ""


# 消除工具中的彩色输出字符
def remove_ansi_escape_sequences(text):
    ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
    return ansi_escape.sub('', text)


def sendmessage(message):
    headers = {'Content-Type': "application/json"}

    global init
    global plannow
    global previous_step
    global step_count
    target = message
    if target == "quit":
        init = False
        return "任务完毕"

    resp = ""

    if not init:
        plannow = p.query2bot(target)["choices"][0]["message"]["content"]
        print(plannow)
        resp += plannow
        resp += "\n[cut]"
        init = True

        while True:
            inst = getInst(plannow)
            current_step = extract_step(inst)  # 提取任务标号
            if current_step is None:
                print(f"无法解析任务标号：{inst}")
                resp += f"无法解析任务标号：{inst}"
                
                return resp
            if current_step == previous_step:
                step_count += 1
            else:
                step_count = 1  # 遇到不同的标号，重置计数
                previous_step = current_step  # 更新上一次的标号
            if step_count >= max_repeats:
                plannow = r.query2bot(plannow, "该步骤已失败且无法完成，请生成或跳到下一步骤")["choices"][0]["message"]["content"].replace(
                    "[new plan", "[plan")
                break
            print(f"tempora instruction is {inst}")
            resp += f"tempora instruction is {inst}"
            resp += "\n[cut]"
            ans = c.query2bot(inst)["choices"][0]["message"]["content"]
            if ans == "auto":
                res = requests.post("http://localhost:7999/chat", json={"question": inst}, headers=headers)
                code = res.status_code
                if code == 200:
                    msg = res.json()["msg"]
                    msg = remove_ansi_escape_sequences(msg)
                    data = res.json()["data"]
                    return_code = res.json()["code"]
                    check_res = pc.query2bot(return_code, msg)["choices"][0]["message"]["content"]
                    print("check_res:", check_res)
                    if check_res[:4] == "任务失败":
                        resp += f"{check_res}"
                        # return resp
                        res = check_res
                    print("return code: ", return_code)
                    print(f"post return msg {msg},data {data}")
                    resp += f"post return msg {msg},data {data}"
                    resp += "\n[cut]"

                else:
                    print(f"error occurred, error code {code}")
                    resp += f"error occurred, error code {code}"
                    resp += "\n"
                    
                    return resp

                if type(res) == requests.models.Response:
                    # print(res.text)
                    res = res.text
                    res = json.loads(res)
                print("res_msg:", res)
                plannow = r.query2bot(plannow, res)["choices"][0]["message"]["content"].replace(
                    "[new plan", "[plan")
            elif ans == "anal":
                res = a.query2bot(inst, msg)["choices"][0]["message"]["content"]
                print(f"{res}")
                resp += f"{res}"
                resp += "\n[cut]"
                plannow = r.query2bot(plannow, res)["choices"][0]["message"]["content"].replace("[new plan", "[plan")

            else:
                print("请输入目前步骤的结果（输入'quit'退出）: ")
                resp += "请输入目前步骤的结果（输入'quit'退出）: "
                resp += "\n"
                
                return resp

    else:
        res = message
        if type(res) == requests.models.Response:
            print(res.text)
            res = res.text
        plannow = r.query2bot(plannow, res)["choices"][0]["message"]["content"].replace("[new plan", "[plan")

        while True:
            inst = getInst(plannow)
            current_step = extract_step(inst)  # 提取任务标号
            if current_step is None:
                print(f"无法解析任务标号：{inst}")
                resp += f"无法解析任务标号：{inst}"
                
                return resp
            if current_step == previous_step:
                step_count += 1
            else:
                step_count = 1  # 遇到不同的标号，重置计数
                previous_step = current_step  # 更新上一次的标号
            if step_count >= max_repeats:
                plannow = r.query2bot(plannow, "该步骤已失败且无法完成，请生成或跳到下一步骤")["choices"][0]["message"]["content"].replace(
                    "[new plan", "[plan")
                break
            print(f"tempora instruction is {inst}")
            resp += f"tempora instruction is {inst}"
            resp += "\n[cut]"

            ans = c.query2bot(inst)["choices"][0]["message"]["content"]
            if ans == "auto":
                res = requests.post("http://localhost:7999/chat", json={"question": inst}, headers=headers)
                code = res.status_code
                if code == 200:
                    msg = res.json()["msg"]
                    msg = remove_ansi_escape_sequences(msg)
                    data = res.json()["data"]
                    return_code = res.json()["code"]
                    check_res = pc.query2bot(return_code, msg)["choices"][0]["message"]["content"]
                    print("check_res:", check_res)
                    if '任务失败' in check_res:
                        resp += f"{check_res}"
                        # return resp
                        res = check_res
                    print("return code: ", return_code)
                    print(f"post return msg {msg},data {data}")
                    resp += f"post return msg {msg},data {data}"
                    resp += "\n[cut]"
                else:
                    print(f"error occurred, error code {code}")
                    resp += f"error occurred, error code {code}"
                    resp += "\n"
                    
                    return resp

                if type(res) == requests.models.Response:
                    # print(res.text)
                    res = res.text
                    res = json.loads(res)
                print("res_msg:", res)
                plannow = r.query2bot(plannow, res)["choices"][0]["message"]["content"].replace(
                    "[new plan", "[plan")
            elif ans == "anal":
                res = a.query2bot(inst, msg)["choices"][0]["message"]["content"]
                print(f"{res}")
                resp += f"{res}"
                resp += "\n[cut]"
                plannow = r.query2bot(plannow, res)["choices"][0]["message"]["content"].replace("[new plan", "[plan")
            else:
                print("请输入目前步骤的结果（输入'quit'退出）: ")
                resp += "请输入目前步骤的结果（输入'quit'退出）: "
                resp += "\n"
                
                return resp
    print("ehdskjafbkajgfnbasg\n\n\n")
    return resp

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8001, debug=False)
